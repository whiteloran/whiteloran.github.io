<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Leetcode 初级算法-链表</title>
      <link href="2022/04/15/22041501/"/>
      <url>2022/04/15/22041501/</url>
      
        <content type="html"><![CDATA[<h1 id="初级算法-链表"><a href="#初级算法-链表" class="headerlink" title="初级算法-链表"></a>初级算法-链表</h1><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><p>链表是一种线性数据结构。</p><p>查找O(n)，删除O(1)，插入O(1)，随机读取O(n)。</p><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><h3 id="节点关系："><a href="#节点关系：" class="headerlink" title="节点关系："></a>节点关系：</h3><p>对于链表来说，我们通常没有办法知晓链表的全貌，只能了解从已知的当前节点开始的表的内容。所以，在对链表问题做处理时，考虑节点之间的关系（主要是当前节点相关的函数关系）是解决链表问题的主要手段。</p><p>所以，在进行链表题时，预先将整个链表的处理流程书写完毕再写代码有事半功倍的效果。</p><h3 id="表头设置（浅拷贝）："><a href="#表头设置（浅拷贝）：" class="headerlink" title="表头设置（浅拷贝）："></a>表头设置（浅拷贝）：</h3><p>由于链表通常需要使用对象的<code>next</code>方法来获取下一节点，所以为了在处理完整个链表后，可以对初始节点进行返回，对表头节点进行浅拷贝是非常有用的。</p><p>在这里需要注意，对next节点的继承需要在当前节点处理之前，不然会因为浅拷贝而改变next节点的状态。</p><p>此外需要注意，随着对head的迭代或者递归，直接指定表头节点的next为head是无效的手段。</p><h3 id="迭代或递归："><a href="#迭代或递归：" class="headerlink" title="迭代或递归："></a>迭代或递归：</h3><h3 id="双指针法："><a href="#双指针法：" class="headerlink" title="双指针法："></a>双指针法：</h3><p>重点看反转链表一题。</p><span id="more"></span><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237. 删除链表中的节点"></a>237. 删除链表中的节点</h3><h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><p><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/">https://leetcode-cn.com/problems/delete-node-in-a-linked-list/</a></p><p>请编写一个函数，用于 删除单链表中某个特定节点 。在设计函数时需要注意，你无法访问链表的头节点 head ，只能直接访问 要被删除的节点 。</p><p>题目数据保证需要删除的节点 不是末尾节点 。</p><p><strong>示例 1：</strong></p><img data-src="https://assets.leetcode.com/uploads/2020/09/01/node1.jpg" alt="img" style="zoom:67%;" /><pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; [4,5,1,9], node &#x3D; 5输出：[4,1,9]解释：指定链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><img data-src="https://assets.leetcode.com/uploads/2020/09/01/node2.jpg" alt="img" style="zoom:67%;" /><pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; [4,5,1,9], node &#x3D; 1输出：[4,5,9]解释：指定链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>提示：</p><pre class="line-numbers language-none"><code class="language-none">链表中节点的数目范围是 [2, 1000]-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000链表中每个节点的值都是 唯一 的需要删除的节点 node 是 链表中的节点 ，且 不是末尾节点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># Definition for singly-linked list.</span><span class="token comment"># class ListNode:</span><span class="token comment">#     def __init__(self, x):</span><span class="token comment">#         self.val = x</span><span class="token comment">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type node: ListNode        :rtype: void Do not return anything, modify node in-place instead.        """</span>        <span class="token comment"># 将下一个节点拉到当前的位置来</span>        <span class="token keyword">if</span> node<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">:</span>             node<span class="token punctuation">.</span>val <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span>val            node<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span><span class="token builtin">next</span>        <span class="token keyword">else</span><span class="token punctuation">:</span> node<span class="token punctuation">.</span>val <span class="token operator">=</span> <span class="token boolean">None</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a>19. 删除链表的倒数第 N 个结点</h3><h4 id="问题：-1"><a href="#问题：-1" class="headerlink" title="问题："></a>问题：</h4><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/</a></p><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2输出：[1,2,3,5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例 2：</p><pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; [1], n &#x3D; 1输出：[]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例 3：</p><pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; [1,2], n &#x3D; 1输出：[1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li>链表中结点的数目为 <code>sz</code></li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul><h4 id="解答：-1"><a href="#解答：-1" class="headerlink" title="解答："></a>解答：</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># Definition for singly-linked list.</span><span class="token comment"># class ListNode:</span><span class="token comment">#     def __init__(self, val=0, next=None):</span><span class="token comment">#         self.val = val</span><span class="token comment">#         self.next = next</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">removeNthFromEnd</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        k <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> head<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">!=</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            k<span class="token punctuation">.</span>append<span class="token punctuation">(</span>head<span class="token punctuation">)</span>            head <span class="token operator">=</span> head<span class="token punctuation">.</span><span class="token builtin">next</span>        k<span class="token punctuation">.</span>append<span class="token punctuation">(</span>head<span class="token punctuation">)</span>        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">>=</span><span class="token number">2</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> k<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">None</span>        <span class="token keyword">elif</span> n<span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token keyword">and</span> n<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> k<span class="token punctuation">[</span><span class="token operator">-</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> k<span class="token punctuation">[</span><span class="token operator">-</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">and</span> n <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">:</span>                k<span class="token punctuation">[</span><span class="token operator">-</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> k<span class="token punctuation">[</span><span class="token operator">-</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                 k<span class="token punctuation">[</span><span class="token operator">-</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> <span class="token boolean">None</span>        <span class="token keyword">elif</span> n<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>            k<span class="token punctuation">[</span><span class="token operator">-</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> <span class="token boolean">None</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">None</span>        <span class="token keyword">return</span> k<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是，以上代码还是在模拟题目的表层模式，如果想要写的更加简单，应该思考如何从表层模式过渡到深层模式。</p><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h3><h4 id="问题：-2"><a href="#问题：-2" class="headerlink" title="问题："></a>问题：</h4><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">https://leetcode-cn.com/problems/reverse-linked-list/</a></p><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; [1,2,3,4,5]输出：[5,4,3,2,1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; [1,2]输出：[2,1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 3：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; []输出：[]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>提示：</p><pre class="line-numbers language-none"><code class="language-none">链表中节点的数目范围是 [0, 5000]-5000 &lt;&#x3D; Node.val &lt;&#x3D; 5000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p><h4 id="解答：-2"><a href="#解答：-2" class="headerlink" title="解答："></a>解答：</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># Definition for singly-linked list.</span><span class="token comment"># class ListNode:</span><span class="token comment">#     def __init__(self, val=0, next=None):</span><span class="token comment">#         self.val = val</span><span class="token comment">#         self.next = next</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> head<span class="token punctuation">:</span> <span class="token keyword">return</span> head        <span class="token keyword">elif</span> <span class="token keyword">not</span> head<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">:</span> <span class="token keyword">return</span> head        <span class="token keyword">else</span><span class="token punctuation">:</span>            pre <span class="token operator">=</span> <span class="token boolean">None</span>            cur <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span>            cur <span class="token operator">=</span> head            <span class="token comment"># 迭代</span>            <span class="token keyword">while</span> cur<span class="token punctuation">:</span>                <span class="token comment"># 继承next</span>                tmp <span class="token operator">=</span> cur<span class="token punctuation">.</span><span class="token builtin">next</span>                <span class="token comment"># 开始处理</span>                cur<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> pre                 <span class="token comment"># 进位</span>                pre <span class="token operator">=</span> cur                cur <span class="token operator">=</span> tmp            <span class="token keyword">return</span> pre<span class="token keyword">def</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> head<span class="token punctuation">:</span> <span class="token keyword">return</span> head        <span class="token keyword">elif</span> <span class="token keyword">not</span> head<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">:</span> <span class="token keyword">return</span> head        <span class="token keyword">else</span><span class="token punctuation">:</span>            pre <span class="token operator">=</span> <span class="token boolean">None</span>            cur <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span>            cur <span class="token operator">=</span> head            <span class="token comment"># 迭代</span>            <span class="token keyword">while</span> cur<span class="token punctuation">:</span>                <span class="token comment"># 继承next</span>                tmp <span class="token operator">=</span> cur<span class="token punctuation">.</span><span class="token builtin">next</span>                <span class="token comment"># 开始处理</span>                cur<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> pre                 <span class="token comment"># 进位</span>                pre <span class="token operator">=</span> cur                cur <span class="token operator">=</span> tmp            <span class="token keyword">return</span> pre<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h3><h4 id="问题：-3"><a href="#问题：-3" class="headerlink" title="问题："></a>问题：</h4><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">https://leetcode-cn.com/problems/merge-two-sorted-lists/</a></p><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例 1：</p><p> <img data-src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]输出：[1,1,2,3,4,4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例 2：</p><pre class="line-numbers language-none"><code class="language-none">输入：l1 &#x3D; [], l2 &#x3D; []输出：[]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例 3：</p><pre class="line-numbers language-none"><code class="language-none">输入：l1 &#x3D; [], l2 &#x3D; [0]输出：[0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>提示：</p><pre class="line-numbers language-none"><code class="language-none">两个链表的节点数目范围是 [0, 50]-100 &lt;&#x3D; Node.val &lt;&#x3D; 100l1 和 l2 均按 非递减顺序 排列<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解答：-3"><a href="#解答：-3" class="headerlink" title="解答："></a>解答：</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># Definition for singly-linked list.</span><span class="token comment"># class ListNode:</span><span class="token comment">#     def __init__(self, val=0, next=None):</span><span class="token comment">#         self.val = val</span><span class="token comment">#         self.next = next</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> list1<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>ListNode<span class="token punctuation">]</span><span class="token punctuation">,</span> list2<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>ListNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> Optional<span class="token punctuation">[</span>ListNode<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> list1<span class="token punctuation">:</span> <span class="token keyword">return</span> list2        <span class="token keyword">if</span> <span class="token keyword">not</span> list2<span class="token punctuation">:</span> <span class="token keyword">return</span> list1        head <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token punctuation">)</span>        cur <span class="token operator">=</span> head        <span class="token keyword">while</span> list1 <span class="token keyword">and</span> list2<span class="token punctuation">:</span>            <span class="token keyword">if</span> list1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> list2<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                cur<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> list1                list1 <span class="token operator">=</span> list1<span class="token punctuation">.</span><span class="token builtin">next</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                cur<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> list2                list2 <span class="token operator">=</span> list2<span class="token punctuation">.</span><span class="token builtin">next</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span><span class="token builtin">next</span>        cur<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> list1 <span class="token keyword">if</span> list1 <span class="token keyword">else</span> list2        <span class="token keyword">return</span> head<span class="token punctuation">.</span><span class="token builtin">next</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a>234. 回文链表</h3><h4 id="问题：-4"><a href="#问题：-4" class="headerlink" title="问题："></a>问题：</h4><p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">https://leetcode-cn.com/problems/palindrome-linked-list/</a></p><p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</p><p>示例 1：</p><p><img data-src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; [1,2,2,1]输出：true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例 2：</p><pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; [1,2]输出：false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>提示：</p><pre class="line-numbers language-none"><code class="language-none">链表中节点数目在范围[1, 105] 内0 &lt;&#x3D; Node.val &lt;&#x3D; 9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>进阶：</strong>你能否用 <code>O(n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度解决此题？</p><h4 id="解答：-4"><a href="#解答：-4" class="headerlink" title="解答："></a>解答：</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># Definition for singly-linked list.</span><span class="token comment"># class ListNode:</span><span class="token comment">#     def __init__(self, val=0, next=None):</span><span class="token comment">#         self.val = val</span><span class="token comment">#         self.next = next</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        k <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> head<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">==</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">while</span> head <span class="token operator">!=</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            k<span class="token punctuation">.</span>append<span class="token punctuation">(</span>head<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            head <span class="token operator">=</span> head<span class="token punctuation">.</span><span class="token builtin">next</span>        <span class="token keyword">if</span> k <span class="token operator">==</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">elif</span> <span class="token builtin">len</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">:</span>            i <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">while</span> i <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> k<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> k<span class="token punctuation">[</span><span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    i <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a>141. 环形链表</h3><h4 id="问题：-5"><a href="#问题：-5" class="headerlink" title="问题："></a>问题：</h4><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/">https://leetcode-cn.com/problems/linked-list-cycle/</a></p><p>给你一个链表的头节点 head ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><p><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">输入：head <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> pos <span class="token operator">=</span> <span class="token number">0</span>输出：true解释：链表中有一个环，其尾部连接到第一个节点。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>示例 3：</strong></p><p><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; [1], pos &#x3D; -1输出：false解释：链表中没有环。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 104]</code></li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li></ul><h4 id="解答：-5"><a href="#解答：-5" class="headerlink" title="解答："></a>解答：</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># Definition for singly-linked list.</span><span class="token comment"># class ListNode:</span><span class="token comment">#     def __init__(self, x):</span><span class="token comment">#         self.val = x</span><span class="token comment">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>ListNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        k <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">**</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> head <span class="token operator">==</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">elif</span> head<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">==</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">elif</span> head <span class="token keyword">not</span> <span class="token keyword">in</span> k<span class="token punctuation">:</span>                k<span class="token punctuation">.</span>append<span class="token punctuation">(</span>head<span class="token punctuation">)</span>                head <span class="token operator">=</span> head<span class="token punctuation">.</span><span class="token builtin">next</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的方法很慢，更好的方法是使用变速双指针。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># Definition for singly-linked list.</span><span class="token comment"># class ListNode:</span><span class="token comment">#     def __init__(self, x):</span><span class="token comment">#         self.val = x</span><span class="token comment">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>ListNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Docs </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 初级算法 </tag>
            
            <tag> chain list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 初级算法-字符串</title>
      <link href="2022/04/12/22041201/"/>
      <url>2022/04/12/22041201/</url>
      
        <content type="html"><![CDATA[<h1 id="初级算法-字符串"><a href="#初级算法-字符串" class="headerlink" title="初级算法-字符串"></a>初级算法-字符串</h1><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><p><strong>数组</strong>是一种<strong>线性数据结构</strong>，其常见复杂度如下：</p><p>查找O(n)，删除O(n)，插入O(n)，随机读取O(1)</p><p>若初始化一个定长数组，可以降低复杂度，但将会失去可变数组带来的简便添加元素和删除元素的方法。</p><p>大部分情况下，字符串可以视作<strong>数组</strong>（或是列表）来考虑。</p><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><h3 id="转换列表"><a href="#转换列表" class="headerlink" title="转换列表"></a>转换列表</h3><p>使用<code>list()</code>函数，将字符串转为列表，再用<code>for</code>循环将结果重新添加回字符串，这是没有更好解决办法时可以使用的技巧。</p><span id="more"></span><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a>344. 反转字符串</h3><h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须<strong>原地</strong>修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>示例 1：</p><pre class="line-numbers language-none"><code class="language-none">输入：s &#x3D; [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例 2：</p><pre class="line-numbers language-none"><code class="language-none">输入：s &#x3D; [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>提示：</p><pre class="line-numbers language-none"><code class="language-none">1 &lt;&#x3D; s.length &lt;&#x3D; 105s[i] 都是 ASCII 码表中的可打印字符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># 双指针法</span>    <span class="token keyword">def</span> <span class="token function">reverseString</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Do not return anything, modify s in-place instead.        """</span>        m <span class="token operator">=</span> <span class="token number">0</span>        n <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">while</span> m<span class="token operator">&lt;=</span><span class="token builtin">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span> <span class="token keyword">and</span> n<span class="token operator">&lt;=</span><span class="token builtin">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">:</span>            s<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span><span class="token operator">-</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span><span class="token operator">-</span>n<span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>m<span class="token punctuation">]</span>            m <span class="token operator">+=</span> <span class="token number">1</span>            n <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token comment"># 列表反转法</span><span class="token keyword">def</span> <span class="token function">reverseString</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        s<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token comment"># 使用 reverse() 函数</span>    <span class="token keyword">def</span> <span class="token function">reverseString</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        s <span class="token operator">=</span> s<span class="token punctuation">.</span>reverse<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a>7. 整数反转</h3><h4 id="问题：-1"><a href="#问题：-1" class="headerlink" title="问题："></a>问题：</h4><p><a href="https://leetcode-cn.com/problems/reverse-integer/">https://leetcode-cn.com/problems/reverse-integer/</a></p><p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</p><p>如果反转后整数超过 32 位的有符号整数的范围 $[−2^{31},  2^{31} − 1] $，就返回 0。</p><p>假设环境不允许存储 64 位整数（有符号或无符号）。</p><h4 id="解答：-1"><a href="#解答：-1" class="headerlink" title="解答："></a>解答：</h4><p><strong>首次解答：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        k <span class="token operator">=</span> <span class="token string">''</span>        <span class="token comment"># 取出正负号</span>        <span class="token keyword">if</span> x <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>            x <span class="token operator">=</span> <span class="token operator">-</span>x            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                k <span class="token operator">+=</span> i            <span class="token comment"># 判断反转后大小是否在范围内</span>            <span class="token keyword">if</span> <span class="token operator">-</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">**</span><span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token operator">-</span><span class="token builtin">int</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token keyword">or</span> <span class="token number">0</span><span class="token operator">-</span><span class="token builtin">int</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">2</span><span class="token operator">**</span><span class="token number">31</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">0</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">0</span><span class="token operator">-</span><span class="token builtin">int</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span>        <span class="token keyword">if</span> x <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                k <span class="token operator">+=</span> i            <span class="token keyword">if</span> <span class="token operator">-</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">**</span><span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token keyword">or</span> <span class="token builtin">int</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">2</span><span class="token operator">**</span><span class="token number">31</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">0</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token builtin">int</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不过，这样来写，在代码上还是比较复杂的，更简单的写法可以考虑使用<code>%</code>和<code>//</code>运算。</p><p><strong>再次解答：</strong></p><h3 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="387. 字符串中的第一个唯一字符"></a>387. 字符串中的第一个唯一字符</h3><h4 id="问题：-2"><a href="#问题：-2" class="headerlink" title="问题："></a>问题：</h4><p><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/">https://leetcode-cn.com/problems/first-unique-character-in-a-string/</a></p><p>给定一个字符串 s ，找到 它的第一个不重复的字符，并返回它的索引 。如果不存在，则返回 -1 。</p><p> 示例 1：</p><pre class="line-numbers language-none"><code class="language-none">输入: s &#x3D; &quot;leetcode&quot;输出: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例 2:</p><pre class="line-numbers language-none"><code class="language-none">输入: s &#x3D; &quot;loveleetcode&quot;输出: 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例 3:</p><pre class="line-numbers language-none"><code class="language-none">输入: s &#x3D; &quot;aabb&quot;输出: -1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>提示:</p><pre class="line-numbers language-none"><code class="language-none">1 &lt;&#x3D; s.length &lt;&#x3D; 105s 只包含小写字母<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="解答：-2"><a href="#解答：-2" class="headerlink" title="解答："></a>解答：</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># 使用count()函数</span>    <span class="token keyword">def</span> <span class="token function">firstUniqChar</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> idx <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> s<span class="token punctuation">.</span>count<span class="token punctuation">(</span>s<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> idx        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token comment"># 使用字典等可变结构</span>    <span class="token keyword">def</span> <span class="token function">firstUniqChar</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        k <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        p <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> idx <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token keyword">in</span> k <span class="token keyword">and</span> s<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token keyword">in</span> p<span class="token punctuation">:</span>                p<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>s<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">continue</span>            <span class="token keyword">elif</span> s<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token keyword">not</span> <span class="token keyword">in</span> k<span class="token punctuation">:</span>                k<span class="token punctuation">[</span>s<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> idx                p<span class="token punctuation">[</span>s<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> idx        <span class="token keyword">if</span> p <span class="token operator">!=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token builtin">list</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但其实，双字典（哈希表）对空间的占用还是大了，观察可知，除了唯一需要的idx之外，其它的字符位置都是不需要的。那么，可以通过修改value来减少字典的使用。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">firstUniqChar</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        k <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> first <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token keyword">for</span> idx <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token keyword">in</span> k<span class="token punctuation">:</span>                k<span class="token punctuation">[</span>s<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>                <span class="token keyword">continue</span>            <span class="token keyword">elif</span> s<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token keyword">not</span> <span class="token keyword">in</span> k<span class="token punctuation">:</span>                k<span class="token punctuation">[</span>s<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> idx        <span class="token keyword">for</span> v <span class="token keyword">in</span> k<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> v <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">and</span> v <span class="token operator">&lt;</span> first<span class="token punctuation">:</span>            first <span class="token operator">=</span> v        <span class="token keyword">if</span> first <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token keyword">return</span> first<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为第二个for所需的最大运行时长固定，所以用时会更短。</p><h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a>242. 有效的字母异位词</h3><h4 id="问题：-3"><a href="#问题：-3" class="headerlink" title="问题："></a>问题：</h4><p><a href="https://leetcode-cn.com/problems/valid-anagram/">https://leetcode-cn.com/problems/valid-anagram/</a></p><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p><p> 示例 1:</p><pre class="line-numbers language-none"><code class="language-none">输入: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;输出: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例 2:</p><pre class="line-numbers language-none"><code class="language-none">输入: s &#x3D; &quot;rat&quot;, t &#x3D; &quot;car&quot;输出: false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>提示:</p><pre class="line-numbers language-none"><code class="language-none">1 &lt;&#x3D; s.length, t.length &lt;&#x3D; 5 * 104s 和 t 仅包含小写字母<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="解答：-3"><a href="#解答：-3" class="headerlink" title="解答："></a>解答：</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># 使用count()</span>    <span class="token keyword">def</span> <span class="token function">isAnagram</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">,</span> t<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        k <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> s<span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token keyword">not</span> <span class="token keyword">in</span> k<span class="token punctuation">:</span>                <span class="token keyword">if</span> s<span class="token punctuation">.</span>count<span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">!=</span> t<span class="token punctuation">.</span>count<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>                k<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token comment"># 使用字典</span>    <span class="token keyword">def</span> <span class="token function">isAnagram</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">,</span> t<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125. 验证回文串"></a>125. 验证回文串</h3><h4 id="问题：-4"><a href="#问题：-4" class="headerlink" title="问题："></a>问题：</h4><p><a href="https://leetcode-cn.com/problems/valid-palindrome/">https://leetcode-cn.com/problems/valid-palindrome/</a></p><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p>说明：本题中，我们将空字符串定义为有效的回文串。</p><p>示例 1:</p><pre class="line-numbers language-none"><code class="language-none">输入: &quot;A man, a plan, a canal: Panama&quot;输出: true解释：&quot;amanaplanacanalpanama&quot; 是回文串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>示例 2:</p><pre class="line-numbers language-none"><code class="language-none">输入: &quot;race a car&quot;输出: false解释：&quot;raceacar&quot; 不是回文串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>提示：</p><pre class="line-numbers language-none"><code class="language-none">1 &lt;&#x3D; s.length &lt;&#x3D; 2 * 105字符串 s 由 ASCII 字符组成<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="解答：-4"><a href="#解答：-4" class="headerlink" title="解答："></a>解答：</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># 硬写，双指针</span>    <span class="token keyword">def</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        m <span class="token operator">=</span> <span class="token number">0</span>        n <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">while</span> m <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span>n<span class="token punctuation">:</span>               <span class="token keyword">if</span> <span class="token builtin">ord</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">48</span> <span class="token keyword">or</span> <span class="token number">57</span><span class="token operator">&lt;</span><span class="token builtin">ord</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">65</span> <span class="token keyword">or</span> <span class="token number">90</span><span class="token operator">&lt;</span><span class="token builtin">ord</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">97</span> <span class="token keyword">or</span> <span class="token builtin">ord</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">122</span><span class="token punctuation">:</span>                m <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">elif</span> <span class="token builtin">ord</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token operator">-</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">48</span> <span class="token keyword">or</span> <span class="token number">57</span><span class="token operator">&lt;</span><span class="token builtin">ord</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token operator">-</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">65</span> <span class="token keyword">or</span> <span class="token number">90</span><span class="token operator">&lt;</span><span class="token builtin">ord</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token operator">-</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">97</span> <span class="token keyword">or</span> <span class="token builtin">ord</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token operator">-</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">122</span><span class="token punctuation">:</span>                n <span class="token operator">=</span> n <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token builtin">ord</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token builtin">ord</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token operator">-</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">or</span> <span class="token builtin">ord</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token builtin">ord</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token operator">-</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">32</span> <span class="token keyword">or</span> <span class="token builtin">ord</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">32</span> <span class="token operator">==</span> <span class="token builtin">ord</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token operator">-</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> <span class="token builtin">ord</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token builtin">ord</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token operator">-</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        <span class="token keyword">if</span> <span class="token builtin">ord</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">58</span> <span class="token keyword">or</span> <span class="token builtin">ord</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token operator">-</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">58</span><span class="token punctuation">:</span>                            <span class="token keyword">return</span> <span class="token boolean">False</span>                    m <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span> n <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8. 字符串转换整数 (atoi)"></a>8. 字符串转换整数 (atoi)</h3><h4 id="问题：-5"><a href="#问题：-5" class="headerlink" title="问题："></a>问题：</h4><p><a href="https://leetcode-cn.com/problems/string-to-integer-atoi">https://leetcode-cn.com/problems/string-to-integer-atoi</a></p><p>请你来实现一个 <code>myAtoi(string s) </code>函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 <code>atoi</code> 函数）。</p><p>函数<code>myAtoi(string s)</code>的算法如下：</p><ul><li><p>读入字符串并丢弃无用的前导空格</p></li><li><p>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</p></li><li><p>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</p></li><li><p>将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。</p></li><li><p>如果整数数超过 32 位有符号整数范围 $[−2^{31},  2^{31} − 1]$ ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 $−2^{31}$ 的整数应该被固定为 $−2^{31}$ ，大于 $2^{31} − 1$ 的整数应该被固定为 $2^{31} − 1$。</p></li><li><p>返回整数作为最终结果。</p></li></ul><p>注意：</p><pre class="line-numbers language-none"><code class="language-none">本题中的空白字符只包括空格字符 &#39; &#39; 。除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="解答：-5"><a href="#解答：-5" class="headerlink" title="解答："></a>解答：</h4><h3 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28. 实现 strStr()"></a>28. 实现 strStr()</h3><h4 id="问题：-6"><a href="#问题：-6" class="headerlink" title="问题："></a>问题：</h4><p><a href="https://leetcode-cn.com/problems/implement-strstr">https://leetcode-cn.com/problems/implement-strstr</a></p><p>实现 <code>strStr() </code>函数。</p><p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。</p><p>说明：</p><p>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p><p>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的<code>strstr()</code>以及 Java 的<code>indexOf()</code>定义相符。</p><p>示例 1：</p><pre class="line-numbers language-none"><code class="language-none">输入：haystack &#x3D; &quot;hello&quot;, needle &#x3D; &quot;ll&quot;输出：2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例 2：</p><pre class="line-numbers language-none"><code class="language-none">输入：haystack &#x3D; &quot;aaaaa&quot;, needle &#x3D; &quot;bba&quot;输出：-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例 3：</p><pre class="line-numbers language-none"><code class="language-none">输入：haystack &#x3D; &quot;&quot;, needle &#x3D; &quot;&quot;输出：0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>提示：</p><pre class="line-numbers language-none"><code class="language-none">1 &lt;&#x3D; haystack.length, needle.length &lt;&#x3D; 104haystack 和 needle 仅由小写英文字符组成<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="解答：-6"><a href="#解答：-6" class="headerlink" title="解答："></a>解答：</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">strStr</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> haystack<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">,</span> needle<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> haystack <span class="token operator">==</span> needle <span class="token operator">==</span> <span class="token string">''</span> <span class="token keyword">or</span> needle <span class="token operator">==</span> <span class="token string">''</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">elif</span> haystack <span class="token operator">==</span> <span class="token string">''</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment"># 这个地方有点作弊了，或许不应该用 in 这个效果。</span>            <span class="token keyword">if</span> needle <span class="token keyword">in</span> haystack<span class="token punctuation">:</span>                   <span class="token keyword">for</span> idx <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>haystack<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    k <span class="token operator">=</span> <span class="token number">0</span>                    <span class="token keyword">if</span> <span class="token builtin">list</span><span class="token punctuation">(</span>haystack<span class="token punctuation">)</span><span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token builtin">list</span><span class="token punctuation">(</span>needle<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                        <span class="token keyword">for</span> iidx <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>needle<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                            <span class="token keyword">if</span> <span class="token builtin">list</span><span class="token punctuation">(</span>needle<span class="token punctuation">)</span><span class="token punctuation">[</span>iidx<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token builtin">list</span><span class="token punctuation">(</span>haystack<span class="token punctuation">)</span><span class="token punctuation">[</span>idx<span class="token operator">+</span>iidx<span class="token punctuation">]</span><span class="token punctuation">:</span>                               k <span class="token operator">+=</span> <span class="token number">1</span>                    <span class="token keyword">if</span> k <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>needle<span class="token punctuation">)</span><span class="token punctuation">:</span>                        <span class="token keyword">return</span> idx                       <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="38. 外观数列"></a>38. 外观数列</h3><h4 id="问题：-7"><a href="#问题：-7" class="headerlink" title="问题："></a>问题：</h4><p><a href="https://leetcode-cn.com/problems/count-and-say/">https://leetcode-cn.com/problems/count-and-say/</a></p><p>给定一个正整数 n ，输出外观数列的第 n 项。</p><p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。</p><p>你可以将其视作是由递归公式定义的数字字符串序列：</p><p><code>countAndSay(1) = &quot;1&quot;</code><br><code>countAndSay(n)</code> 是对 <code>countAndSay(n-1) </code>的描述，然后转换成另一个数字字符串。<br>前五项如下：</p><pre class="line-numbers language-none"><code class="language-none">1.     12.     113.     214.     12115.     111221       第一项是数字 1        描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 &quot;11&quot;       描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 &quot;21&quot;       描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 &quot;1211&quot;       描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 &quot;111221&quot;要 描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如，数字字符串 “3322251” 的描述如下图：</p><p><img data-src="https://pic.leetcode-cn.com/1629874763-TGmKUh-image.png" alt="img"></p><p>示例 1：</p><pre class="line-numbers language-none"><code class="language-none">输入：n &#x3D; 1输出：&quot;1&quot;解释：这是一个基本样例。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>示例 2：</p><pre class="line-numbers language-none"><code class="language-none">输入：n &#x3D; 4输出：&quot;1211&quot;解释：countAndSay(1) &#x3D; &quot;1&quot;countAndSay(2) &#x3D; 读 &quot;1&quot; &#x3D; 一 个 1 &#x3D; &quot;11&quot;countAndSay(3) &#x3D; 读 &quot;11&quot; &#x3D; 二 个 1 &#x3D; &quot;21&quot;countAndSay(4) &#x3D; 读 &quot;21&quot; &#x3D; 一 个 2 + 一 个 1 &#x3D; &quot;12&quot; + &quot;11&quot; &#x3D; &quot;1211&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>提示：</p><pre class="line-numbers language-none"><code class="language-none">1 &lt;&#x3D; n &lt;&#x3D; 30<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="解答：-7"><a href="#解答：-7" class="headerlink" title="解答："></a>解答：</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">countAndSay</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">str</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token string">'1'</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment"># 设置递归</span>            s <span class="token operator">=</span> self<span class="token punctuation">.</span>countAndSay<span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            cnt<span class="token punctuation">,</span> digit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>            res <span class="token operator">=</span> <span class="token string">''</span>            <span class="token keyword">for</span> ch <span class="token keyword">in</span> s<span class="token punctuation">:</span>                <span class="token keyword">if</span> ch <span class="token operator">==</span> digit<span class="token punctuation">:</span>                    cnt <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    res <span class="token operator">+=</span> <span class="token string-interpolation"><span class="token string">f'</span><span class="token interpolation"><span class="token punctuation">&#123;</span>cnt<span class="token punctuation">&#125;</span></span><span class="token interpolation"><span class="token punctuation">&#123;</span>digit<span class="token punctuation">&#125;</span></span><span class="token string">'</span></span>                    digit <span class="token operator">=</span> ch                    cnt <span class="token operator">=</span> <span class="token number">1</span>            <span class="token keyword">return</span> <span class="token string-interpolation"><span class="token string">f'</span><span class="token interpolation"><span class="token punctuation">&#123;</span>res<span class="token punctuation">&#125;</span></span><span class="token interpolation"><span class="token punctuation">&#123;</span>cnt<span class="token punctuation">&#125;</span></span><span class="token interpolation"><span class="token punctuation">&#123;</span>digit<span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a>14. 最长公共前缀</h3><h4 id="问题：-8"><a href="#问题：-8" class="headerlink" title="问题："></a>问题：</h4><p><a href="https://leetcode-cn.com/problems/longest-common-prefix/">https://leetcode-cn.com/problems/longest-common-prefix/</a></p><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 “”。</p><p>示例 1：</p><pre class="line-numbers language-none"><code class="language-none">输入：strs &#x3D; [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出：&quot;fl&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例 2：</p><pre class="line-numbers language-none"><code class="language-none">输入：strs &#x3D; [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出：&quot;&quot;解释：输入不存在公共前缀。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>提示：</p><pre class="line-numbers language-none"><code class="language-none">1 &lt;&#x3D; strs.length &lt;&#x3D; 2000 &lt;&#x3D; strs[i].length &lt;&#x3D; 200strs[i] 仅由小写英文字母组成<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解答：-8"><a href="#解答：-8" class="headerlink" title="解答："></a>解答：</h4><p><strong>初次解答：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">longestCommonPrefix</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> strs<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">str</span><span class="token punctuation">:</span>        p <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>strs<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>strs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                m <span class="token operator">=</span> strs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span>                <span class="token comment"># 虽然try except有效，但这种写法还是太怪了一点。</span>                <span class="token keyword">try</span><span class="token punctuation">:</span>                    <span class="token keyword">for</span> k <span class="token keyword">in</span> strs<span class="token punctuation">:</span>                        <span class="token keyword">if</span> k<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> m<span class="token punctuation">:</span>                            <span class="token keyword">continue</span>                        <span class="token keyword">else</span><span class="token punctuation">:</span>                            <span class="token comment"># 重复部分</span>                            x <span class="token operator">=</span> <span class="token string">''</span>                            <span class="token keyword">for</span> t <span class="token keyword">in</span> p<span class="token punctuation">:</span>                                x <span class="token operator">+=</span> t                             <span class="token keyword">return</span> x                    p<span class="token punctuation">.</span>append<span class="token punctuation">(</span>m<span class="token punctuation">)</span>                <span class="token keyword">except</span> Exception<span class="token punctuation">:</span>                    <span class="token comment"># 重复部分</span>                    x <span class="token operator">=</span> <span class="token string">''</span>                    <span class="token keyword">for</span> t <span class="token keyword">in</span> p<span class="token punctuation">:</span>                        x <span class="token operator">+=</span> t                     <span class="token keyword">return</span> x            <span class="token comment"># 重复部分</span>            x <span class="token operator">=</span> <span class="token string">''</span>            <span class="token keyword">for</span> t <span class="token keyword">in</span> p<span class="token punctuation">:</span>                x <span class="token operator">+=</span> t             <span class="token keyword">return</span> x        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> strs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>               <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码重复部分太多，同时使用了try except结构，非常需要优化的。</p><p>这种情况的出现，是因为对整个题目和解法进行了很直接的判断，出现问题就解决问题，于是打了多次补丁来针对性地解决问题。这并不是一个正确的思路。</p><p>在书写代码遇到对模式的直接模拟出现错误时，单纯地使用增量代码的方式补足缺陷是不好的。更好的办法是修改当前代码的模式，通过改变此时代码在非判断和非循环下的适应性才是更合适的。</p><p>确切来说，当模拟模式时，需要考虑的不是直观模式，而是代码结构对非直观模式的反映和处理。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">longestCommonPrefix</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> strs<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">str</span><span class="token punctuation">:</span>res<span class="token punctuation">,</span> col <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token comment"># 不变的矩阵查找</span>            ch <span class="token operator">=</span> strs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span>            <span class="token comment"># 循环</span>            <span class="token keyword">for</span> row <span class="token keyword">in</span> strs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token comment"># 通过新的判断语句避免out of range</span>                <span class="token keyword">if</span> col <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span> <span class="token keyword">and</span> row<span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">!=</span> ch<span class="token punctuation">:</span>                    <span class="token keyword">return</span> res            res <span class="token operator">+=</span> ch            col <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样，也可以写成下面这种形式：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">longestCommonPrefix</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> strs<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">str</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>strs<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token string">''</span>res <span class="token operator">=</span> <span class="token string">''</span>        <span class="token keyword">for</span> chs <span class="token keyword">in</span> <span class="token builtin">zip</span><span class="token punctuation">(</span><span class="token operator">*</span>strs<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span><span class="token builtin">set</span><span class="token punctuation">(</span>chs<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                res <span class="token operator">+=</span> chs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token keyword">return</span> res        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Docs </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 初级算法 </tag>
            
            <tag> str </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 初级算法-数组</title>
      <link href="2022/04/04/22040401/"/>
      <url>2022/04/04/22040401/</url>
      
        <content type="html"><![CDATA[<h1 id="初级算法-数组"><a href="#初级算法-数组" class="headerlink" title="初级算法-数组"></a>初级算法-数组</h1><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><p><strong>数组</strong>是一种<strong>线性数据结构</strong>，其常见复杂度如下：</p><p>查找O(n)，删除O(n)，插入O(n)，随机读取O(1)</p><p>若初始化一个定长数组，可以降低复杂度，但将会失去可变数组带来的简便添加元素和删除元素的方法。</p><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><h3 id="双指针法（多指针法）"><a href="#双指针法（多指针法）" class="headerlink" title="双指针法（多指针法）"></a>双指针法（多指针法）</h3><p>其核心思想是，构建单个（多个）数组中需要交互操作，同时操作，同一操作的两个（多个）位置之间的函数关系，赋予指针变量。这样，即可通过遍历一次由单位向量构成的自变量，达成同时对相应的全部位置进行操作。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>运算符还包括了逻辑运算符，在写代码时不应只留意函数关系的加减乘除。</p><span id="more"></span><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26.删除有序数组中的重复项"></a>26.删除有序数组中的重复项</h3><h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><p>链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array</a></p><p>给你一个 <strong>升序排列</strong> 的数组 nums ，请你 <strong>原地</strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。</p><p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。</p><p>将最终结果插入 nums 的前 k 个位置后返回 k 。</p><p>不要使用额外的空间，你必须在 <strong>原地</strong> 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p>示例 1：</p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [1,1,2]输出：2, nums &#x3D; [1,2,_]解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>示例 2：</p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [0,0,1,1,1,2,2,3,3,4]输出：5, nums &#x3D; [0,1,2,3,4]解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><details><summary>提示：</summary><pre class="line-numbers language-none"><code class="language-none">0 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 104-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104nums 已按 升序 排列<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></details><h4 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h4><p><strong>首次解答：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        p <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> idx <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>idx<span class="token operator">-</span>p<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>idx<span class="token operator">-</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">del</span> nums<span class="token punctuation">[</span>idx<span class="token operator">-</span>p<span class="token punctuation">]</span>                p <span class="token operator">=</span> p <span class="token operator">+</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><details><summary>Result：</summary><img data-src="https://raw.githubusercontent.com/whiteloran/PicBed/master/img/202204111527491.png"/></details><p><strong>相似解答</strong>：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        p <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> idx <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>idx<span class="token operator">-</span>p<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>idx<span class="token operator">-</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                nums<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>idx<span class="token operator">-</span>p<span class="token punctuation">)</span>                p <span class="token operator">=</span> p <span class="token operator">+</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之所以会这么慢，是因为<code>del</code>本身的复杂度是$O(n)$，同时for循环的复杂度也是$O(n)$。导致了整体的复杂度提升。<br>一个简单的改进方法是使用快慢<strong>激励</strong>双指针，两个指针初始相差一位，当两者数值不同，就将快指针指向的值赋予慢指针指向的位置，同时两指针都向前一步；当两者数值相同，或是<strong>快</strong>指针前后相同，则仅仅激励<strong>快</strong>指针。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        i <span class="token operator">=</span> <span class="token number">0</span>        j <span class="token operator">=</span> <span class="token number">1</span>        <span class="token comment"># 提前保存首位</span>        p <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> i <span class="token operator">&lt;=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">and</span> j <span class="token operator">&lt;=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token keyword">or</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">:</span>                j <span class="token operator">=</span> j <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> nums <span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>                j <span class="token operator">=</span> j <span class="token operator">+</span> <span class="token number">1</span>        <span class="token comment"># 重新放回首位</span>        nums<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>p<span class="token punctuation">)</span>        <span class="token keyword">return</span> i<span class="token operator">+</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a>122. 买卖股票的最佳时机 II</h3><h4 id="问题：-1"><a href="#问题：-1" class="headerlink" title="问题："></a>问题：</h4><p>给定一个数组 prices ，其中 prices[i] 表示股票第 i 天的价格。</p><p>在每一天，你可能会决定购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以购买它，然后在** 同一天** 出售。<br>返回 你能获得的 <strong>最大</strong> 利润 。</p><p>示例 1:</p><pre class="line-numbers language-none"><code class="language-none">输入: prices &#x3D; [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>示例 2:</p><pre class="line-numbers language-none"><code class="language-none">输入: prices &#x3D; [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>示例 3:</p><pre class="line-numbers language-none"><code class="language-none">输入: prices &#x3D; [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>提示：</p><pre class="line-numbers language-none"><code class="language-none">1 &lt;&#x3D; prices.length &lt;&#x3D; 3 * 1040 &lt;&#x3D; prices[i] &lt;&#x3D; 104<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="解答：-1"><a href="#解答：-1" class="headerlink" title="解答："></a>解答：</h4><p><strong>首次解答：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">global</span> highest        <span class="token keyword">global</span> k         highest <span class="token operator">=</span> <span class="token number">0</span>        k <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> idx <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>prices<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> Solution<span class="token punctuation">.</span>iterer<span class="token punctuation">(</span>idx<span class="token punctuation">,</span>prices<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token keyword">and</span> idx <span class="token keyword">not</span> <span class="token keyword">in</span> k<span class="token punctuation">:</span>                Solution<span class="token punctuation">.</span>iterer<span class="token punctuation">(</span>idx<span class="token punctuation">,</span>prices<span class="token punctuation">)</span>        <span class="token keyword">return</span> highest                <span class="token keyword">def</span> <span class="token function">iterer</span><span class="token punctuation">(</span>idx<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> prices<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> higher<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment">#global k</span>        <span class="token keyword">global</span> highest        <span class="token keyword">for</span> length <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>prices<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>idx<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> prices<span class="token punctuation">[</span>idx<span class="token operator">+</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token operator">+</span>higher<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                     <span class="token keyword">if</span> prices<span class="token punctuation">[</span>idx<span class="token operator">+</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token operator">+</span>higher<span class="token operator">></span>highest<span class="token punctuation">:</span>                    highest <span class="token operator">=</span> prices<span class="token punctuation">[</span>idx<span class="token operator">+</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token operator">+</span>higher            <span class="token keyword">if</span> idx<span class="token operator">+</span>length<span class="token operator">+</span><span class="token number">2</span> <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>prices<span class="token punctuation">)</span> <span class="token keyword">and</span> idx<span class="token operator">+</span>length<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">:</span>                <span class="token keyword">for</span> idx2 <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>prices<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>idx<span class="token operator">+</span>length<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token comment"># 无限递归</span>                    Solution<span class="token punctuation">.</span>iterer<span class="token punctuation">(</span>idx2<span class="token operator">+</span>idx<span class="token operator">+</span>length<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span>prices<span class="token punctuation">,</span>prices<span class="token punctuation">[</span>idx<span class="token operator">+</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token operator">+</span>higher<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码在数组大的时候超时了。原因是因为无限递归的时间复杂度太高。这种时候，就应该分析题设没有给出的数学条件。<br>可以看出，隔多日买入卖出，可以视为每一日都买入卖出的加和。<br>这样，为了达成最优获利，只需要将能盈利的每日都相加即可。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        highest <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>prices<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            highest <span class="token operator">+=</span> <span class="token builtin">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> highest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189. 轮转数组"></a>189. 轮转数组</h3><h4 id="问题：-2"><a href="#问题：-2" class="headerlink" title="问题："></a>问题：</h4><p>给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。</p><p>示例 1:</p><pre class="line-numbers language-none"><code class="language-none">输入: nums &#x3D; [1,2,3,4,5,6,7], k &#x3D; 3输出: [5,6,7,1,2,3,4]解释:向右轮转 1 步: [7,1,2,3,4,5,6]向右轮转 2 步: [6,7,1,2,3,4,5]向右轮转 3 步: [5,6,7,1,2,3,4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例 2:</p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [-1,-100,3,99], k &#x3D; 2输出：[3,99,-1,-100]解释: 向右轮转 1 步: [99,-1,-100,3]向右轮转 2 步: [3,99,-1,-100]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>提示：</p><pre class="line-numbers language-none"><code class="language-none">1 &lt;&#x3D; nums.length &lt;&#x3D; 105-231 &lt;&#x3D; nums[i] &lt;&#x3D; 231 - 10 &lt;&#x3D; k &lt;&#x3D; 105<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解答：-2"><a href="#解答：-2" class="headerlink" title="解答："></a>解答：</h4><p><strong>首次解答：</strong></p><ol><li>简单法：<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">rotate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Do not return anything, modify nums in-place instead.        """</span>        <span class="token keyword">for</span> idx <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>            nums<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>nums<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><details><summary>Result：</summary><img data-src="https://raw.githubusercontent.com/whiteloran/PicBed/master/img/202204021643482.png"/></details><p>上述代码写起来还是挺简单的，但insert和pop对时间的消耗比较大。若是想要在一次循环下完成，我们需要额外的空间。</p><ol><li>迭代法：</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">rotate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Do not return anything, modify nums in-place instead.        """</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">:</span>             i <span class="token operator">=</span> <span class="token number">0</span>            j <span class="token operator">=</span> k            <span class="token comment"># 可变类型需要深拷贝才能不受对象变化影响</span>            p <span class="token operator">=</span> copy<span class="token punctuation">.</span>deepcopy<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>            <span class="token keyword">while</span> i<span class="token operator">&lt;=</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">while</span> j <span class="token operator">></span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>                    j <span class="token operator">=</span> j<span class="token operator">-</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>                nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                i <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span>                j <span class="token operator">=</span> j<span class="token operator">+</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两指针分别指向两数组，其间距相差k，对数组长度遍历一遍，即可获得结果。在上述代码中，深拷贝耗费了不少的时间，可以被优化掉。</p><h3 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217. 存在重复元素"></a>217. 存在重复元素</h3><h4 id="问题：-3"><a href="#问题：-3" class="headerlink" title="问题："></a>问题：</h4><p><a href="https://leetcode-cn.com/problems/contains-duplicate/">https://leetcode-cn.com/problems/contains-duplicate/</a></p><p>给你一个整数数组 nums 。如果任一值在数组中出现 <strong>至少两次</strong> ，返回 true ；如果数组中每个元素互不相同，返回 false 。</p><p>示例 1：</p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [1,2,3,1]输出：true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例 2：</p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [1,2,3,4]输出：false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例 3：</p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [1,1,1,3,3,4,3,2,4,2]输出：true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>提示：</p><pre class="line-numbers language-none"><code class="language-none">1 &lt;&#x3D; nums.length &lt;&#x3D; 105-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="解答：-3"><a href="#解答：-3" class="headerlink" title="解答："></a>解答：</h4><p><strong>首次解答：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">containsDuplicate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token comment"># 转为set剔除掉不符元素，再比较长度是否相等</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">set</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token comment"># 等价于</span>    <span class="token keyword">def</span> <span class="token function">containsDuplicate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token keyword">not</span> <span class="token builtin">len</span><span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">set</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了利用set不能保存重复元素的性质，还有没有别的办法可以做到？</p><p>可以使用一种可变数据类型来保存已经存在的内容：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">containsDuplicate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token comment"># s可以使用任何可变可查找的类型，其中，最快的是字典。</span>        s <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token keyword">in</span> s<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                s<span class="token punctuation">.</span>add<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a>136. 只出现一次的数字</h3><h4 id="问题：-4"><a href="#问题：-4" class="headerlink" title="问题："></a>问题：</h4><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例 1:</p><pre class="line-numbers language-none"><code class="language-none">输入: [2,2,1]输出: 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例 2:</p><pre class="line-numbers language-none"><code class="language-none">输入: [4,1,2,1,2]输出: 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="解答：-4"><a href="#解答：-4" class="headerlink" title="解答："></a>解答：</h4><p><strong>首次解答：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">singleNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            <span class="token comment"># 使用计数函数</span>            <span class="token keyword">if</span> nums<span class="token punctuation">.</span>count<span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> i<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但这种方式无疑是十分缓慢的，一种简单的改进方法是使用如上一题的方法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">singleNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># 构造字典</span>        k <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        p <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token keyword">in</span> k<span class="token punctuation">:</span>                p<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>i<span class="token punctuation">)</span>                <span class="token keyword">continue</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                k<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i                p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i        <span class="token comment"># 返回唯一存在的对象</span>        <span class="token keyword">return</span> <span class="token builtin">list</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是，一个新的问题又出现了，这个新方法也没有办法不使用额外空间。如果想要不使用额外空间，那么就得考虑内建的函数（算法）。</p><p>在本题中，需要接触并使用<strong>位运算（逻辑运算）</strong>：</p><p><strong>异或</strong>运算的性质可以在数字电路中简单掌握，相同输出0，不同输出1。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">singleNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># reduce()函数用于累积；lambda用于声明匿名函数。reduce()对范围nums内所有值做lambda()操作，'^'是按位异或运算符。</span>        <span class="token keyword">return</span> <span class="token builtin">reduce</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">,</span> y<span class="token punctuation">:</span> x <span class="token operator">^</span> y<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="350-两个数组的交集-II"><a href="#350-两个数组的交集-II" class="headerlink" title="350. 两个数组的交集 II"></a>350. 两个数组的交集 II</h3><h4 id="问题：-5"><a href="#问题：-5" class="headerlink" title="问题："></a>问题：</h4><p>链接：<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii">https://leetcode-cn.com/problems/intersection-of-two-arrays-ii</a></p><p>给你两个整数数组<code>nums1</code>和<code>nums2</code>，请你以数组形式返回两数组的<strong>交集</strong>。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]输出：[2,2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 2:</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]输出：[4,9]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><details><summary>其它：</summary>**提示：**<pre class="line-numbers language-none"><code class="language-none">1 &lt;&#x3D; nums1.length, nums2.length &lt;&#x3D; 10000 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 1000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>进阶：</strong></p><p>如果给定的数组已经排好序呢？你将如何优化你的算法？<br>如果 nums1 的大小比 nums2 小，哪种方法更优？<br>如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</p></details><h4 id="解答：-5"><a href="#解答：-5" class="headerlink" title="解答："></a>解答：</h4><p><strong>首次解答：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">intersect</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums1<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums2<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        k <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># 遍历数值</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> nums1<span class="token punctuation">:</span>            <span class="token comment"># 避免重复数值</span>            <span class="token keyword">if</span> i <span class="token keyword">not</span> <span class="token keyword">in</span> k<span class="token punctuation">:</span>                <span class="token comment"># 按最小出现次数</span>                <span class="token keyword">for</span> p <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">min</span><span class="token punctuation">(</span>nums1<span class="token punctuation">.</span>count<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span>nums2<span class="token punctuation">.</span>count<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token comment"># 输入数组</span>                    k<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token keyword">return</span> k<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><details><summary>Result：</summary><img data-src="https://raw.githubusercontent.com/whiteloran/PicBed/master/img/202204012238232.png"/></details><p>显然，这个代码的时间复杂程度太高了。为了降低代码的时间复杂度，最为简单能解决的是在中间使用的两个<code>count()</code>【$O(n)$】函数，将它们替换成时间复杂度更低的方法，或者是把它们移出外围<code>for</code>循环。</p><p>那么，一个合理的思路是，‘既然这一步是因为无法统计到元素重复次数，那就将元素重复统计放到循环之前。在这里，可以使用双指针走两个排序<code>sort()</code>【$O(n\times log(n))$】数组来完成。</p><p><strong>再次解答：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">intersect</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums1<span class="token punctuation">,</span> nums2<span class="token punctuation">)</span><span class="token punctuation">:</span>        nums1 <span class="token operator">=</span> <span class="token builtin">sorted</span><span class="token punctuation">(</span>nums1<span class="token punctuation">)</span>        nums2 <span class="token operator">=</span> <span class="token builtin">sorted</span><span class="token punctuation">(</span>nums2<span class="token punctuation">)</span>        i <span class="token operator">=</span> <span class="token number">0</span>        j <span class="token operator">=</span> <span class="token number">0</span>        k <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token punctuation">(</span>j<span class="token operator">&lt;</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                k<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                i <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span>                j <span class="token operator">=</span> j<span class="token operator">+</span><span class="token number">1</span>            <span class="token keyword">elif</span><span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                j <span class="token operator">=</span> j<span class="token operator">+</span><span class="token number">1</span>            <span class="token keyword">elif</span><span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                i <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span>        <span class="token keyword">return</span> k<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="66-加一"><a href="#66-加一" class="headerlink" title="66.加一"></a>66.加一</h3><p><a href="https://leetcode-cn.com/problems/plus-one">https://leetcode-cn.com/problems/plus-one</a></p><h4 id="问题：-6"><a href="#问题：-6" class="headerlink" title="问题："></a>问题：</h4><p>给定一个由<strong>整数</strong>组成的<strong>非空</strong>数组所表示的非负整数，在该数的基础上加一。<br>最高位数字存放在数组的首位，数组中每个元素只存储<strong>单个</strong>数字。<br>你可以假设除了整数<strong>0</strong>之外，这个整数不会以零开头。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：digits &#x3D; [1,2,3]输出：[1,2,4]解释：输入数组表示数字 123。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：digits &#x3D; [4,3,2,1]输出：[4,3,2,2]解释：输入数组表示数字 4321。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>示例 3：</p><pre class="line-numbers language-none"><code class="language-none">输入：digits &#x3D; [0]输出：[1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><details><summary>其它：</summary>提示：1 <= digits.length <= 1000 <= digits[i] <= 9</details><h4 id="解答：-6"><a href="#解答：-6" class="headerlink" title="解答："></a>解答：</h4><p><strong>首次解答：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">plusOne</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> digits<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token comment"># 末位+1</span>        digits<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> digits<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>        <span class="token comment"># 捕捉进位（这个一开始可能忽略掉），其实这里可以只要后面的部分，但是这样会进循环减速。</span>        <span class="token keyword">if</span> digits<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">10</span><span class="token punctuation">:</span>            <span class="token comment"># 循环进位</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>digits<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> digits<span class="token punctuation">[</span><span class="token operator">-</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">10</span><span class="token punctuation">:</span>                    digits<span class="token punctuation">[</span><span class="token operator">-</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>                    <span class="token keyword">if</span> i<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>digits<span class="token punctuation">)</span><span class="token punctuation">:</span>                        <span class="token comment"># 上位+1</span>                        digits<span class="token punctuation">[</span><span class="token operator">-</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> digits<span class="token punctuation">[</span><span class="token operator">-</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        <span class="token comment"># 顶位补长</span>                        digits<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> digits<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><details><summary>Result：</summary><img data-src="https://raw.githubusercontent.com/whiteloran/PicBed/master/img/202204012209196.png"/><img data-src="https://raw.githubusercontent.com/whiteloran/PicBed/master/img/202204012212882.png"/></details><p>发现这样子，时空消耗可能还能进一步缩减，但不是非常必要。那如何缩减代码长度呢？</p><p><strong>一种题解：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">plusOne</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> digits<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">str</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> digits<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><details><summary>Result：</summary><img data-src="https://raw.githubusercontent.com/whiteloran/PicBed/master/img/202204012222766.png"/></details><p>这个题解使用了数据结构的有关方法，在缩减了代码长度的同时，引入了一个新的for，这个可能会增加时间复杂度。</p><h3 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283.移动零"></a>283.移动零</h3><p>链接： <a href="https://leetcode-cn.com/problems/move-zeroes/">https://leetcode-cn.com/problems/move-zeroes/</a></p><h4 id="问题：-7"><a href="#问题：-7" class="headerlink" title="问题："></a>问题：</h4><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。<br>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p><p>示例 1:</p><pre class="line-numbers language-none"><code class="language-none">输入: nums &#x3D; [0,1,0,3,12]输出: [1,3,12,0,0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例 2:</p><pre class="line-numbers language-none"><code class="language-none">输入: nums &#x3D; [0]输出: [0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><details><summary>其它：</summary><p>提示:</p><pre class="line-numbers language-none"><code class="language-none">1 &lt;&#x3D; nums.length &lt;&#x3D; 104-231 &lt;&#x3D; nums[i] &lt;&#x3D; 231 - 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>进阶：你能尽量减少完成的操作次数吗？</p></details><h4 id="解答：-7"><a href="#解答：-7" class="headerlink" title="解答："></a>解答：</h4><p><strong>首次解答：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">moveZeroes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Do not return anything, modify nums in-place instead.        """</span>        <span class="token comment"># 回退指针</span>        p <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment"># 定义范围循环</span>        <span class="token keyword">for</span> idx <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 找0</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>idx<span class="token operator">-</span>p<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token comment"># 原位删除，末尾填补</span>                nums<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>idx<span class="token operator">-</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment"># 指针进位</span>                p <span class="token operator">+=</span> <span class="token number">1</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><details><summary>Result：</summary><img data-src="https://raw.githubusercontent.com/whiteloran/PicBed/master/img/202204012154495.png"/></details><p>这个解答的空间消耗通常，但是时间消耗很大，其主要原因在于<code>pop</code>和<code>append</code>的时间消耗。</p><details><summary>**同类代码如下：**</summary><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">moveZeroes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token comment"># 定义范围循环，这里range从后往前走了</span>        <span class="token keyword">for</span> idx <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                nums<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>idx<span class="token punctuation">)</span>                nums<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img data-src="https://raw.githubusercontent.com/whiteloran/PicBed/master/img/202204012153712.png"/></details><p>从后往前写的话，可以少一个指针的需求。<br>由于<code>pop(i)</code>($O(n)$)和<code>append</code>的影响，单指针在这道题的表现上确实是不如双指针，或者说，在上文中，我虽然定义了<code>p</code>指针，但其没有被有效利用上，所以想要提升效率的话，</p><p><strong>再次解答：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">moveZeroes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        p <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> idx <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token comment"># 交换位置</span>                nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span>                p <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><details><summary>Result：</summary><img data-src="https://raw.githubusercontent.com/whiteloran/PicBed/master/img/202204012157353.png"/></details><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><h4 id="问题：-8"><a href="#问题：-8" class="headerlink" title="问题："></a>问题：</h4><p><a href="https://leetcode-cn.com/problems/two-sum/">https://leetcode-cn.com/problems/two-sum/</a></p><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p>示例 1：</p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9输出：[0,1]解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>示例 2：</p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [3,2,4], target &#x3D; 6输出：[1,2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例 3：</p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [3,3], target &#x3D; 6输出：[0,1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>提示：</p><pre class="line-numbers language-none"><code class="language-none">2 &lt;&#x3D; nums.length &lt;&#x3D; 104-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109-109 &lt;&#x3D; target &lt;&#x3D; 109<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>只会存在一个有效答案。</p><p>进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？</p><h4 id="解答：-8"><a href="#解答：-8" class="headerlink" title="解答："></a>解答：</h4><p><strong>首次解答：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> idx1 <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> idx2 <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>idx1<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>idx2<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">:</span>                    <span class="token keyword">if</span> idx1 <span class="token operator">!=</span> idx2<span class="token punctuation">:</span>                        <span class="token keyword">return</span> <span class="token punctuation">[</span>idx1<span class="token punctuation">,</span>idx2<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显然这是一个$O(n^2) $复杂度的算法，但即使是上面这个程度，也还有优化的空间：因为两个idx之间显然是有对应关系的。每一个在前的元素都已经和后面的元素匹配过了。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> idx1 <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> idx2 <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> idx1 <span class="token operator">&lt;</span> idx2<span class="token punctuation">:</span>                    <span class="token keyword">if</span> nums<span class="token punctuation">[</span>idx1<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>idx2<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">:</span>                        <span class="token keyword">return</span> <span class="token punctuation">[</span>idx1<span class="token punctuation">,</span>idx2<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，以上的双循环方法，随着数组长度的增加，其消耗的时间以二次方增加。将其时间复杂度降低，我们可以观察目前的数据形式。如果使用字典的话，我们可以在内循环中，不必再使用$O(n) $的时间复杂度，而是$O(1) $。与此同时，我们的空间复杂度会提高到$O(n) $。</p><h5 id="再次解答："><a href="#再次解答：" class="headerlink" title="再次解答："></a>再次解答：</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        k <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> idx1 <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> target<span class="token operator">-</span>nums<span class="token punctuation">[</span>idx1<span class="token punctuation">]</span> <span class="token keyword">in</span> k<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token punctuation">[</span>idx1<span class="token punctuation">,</span> k<span class="token punctuation">[</span>target<span class="token operator">-</span>nums<span class="token punctuation">[</span>idx1<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>            k<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>idx1<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> idx1        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，在上述代码中，<em>将当前值与字典进行比较</em> ，和 <em>将当前值加入字典</em> 两步操作的顺序不可调换。程序的运行状态通常会影响程序的处理结果。在本题中，若是对调两个步骤，则无法处理以下情况：</p><pre class="line-numbers language-none"><code class="language-none">[3,3] 6;[3,2,4,6] 6;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通常来说，我们可以将对数据集的修改，放置在操作步骤之后来避免这种情况。当然，具体情况具体分析。</p><blockquote><p>不过对于函数式编程来说，就可以不用那么考虑状态。</p></blockquote><h3 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="36. 有效的数独"></a>36. 有效的数独</h3><h4 id="问题：-9"><a href="#问题：-9" class="headerlink" title="问题："></a>问题：</h4><p><a href="https://leetcode-cn.com/problems/valid-sudoku/">https://leetcode-cn.com/problems/valid-sudoku/</a></p><p>请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。</p><p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）</p><p>注意：</p><p>一个有效的数独（部分已被填充）不一定是可解的。<br>只需要根据以上规则，验证已经填入的数字是否有效即可。<br>空白格用 ‘.’ 表示。</p><img data-src="https://raw.githubusercontent.com/whiteloran/PicBed/master/img/202204122037760.png"/><pre class="line-numbers language-none"><code class="language-none">输入：board &#x3D; [[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出：true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例 2：</p><pre class="line-numbers language-none"><code class="language-none">输入：board &#x3D; [[&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出：false解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="解答：-9"><a href="#解答：-9" class="headerlink" title="解答："></a>解答：</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isValidSudoku</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> board<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>         x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                y<span class="token punctuation">.</span>append<span class="token punctuation">(</span>board<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            x<span class="token punctuation">.</span>append<span class="token punctuation">(</span>y<span class="token punctuation">)</span>        <span class="token keyword">for</span> m <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> n <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                k <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>                p <span class="token operator">=</span> <span class="token number">0</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        <span class="token comment"># 过空格</span>                        <span class="token keyword">if</span> board<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">3</span><span class="token operator">*</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">3</span><span class="token operator">*</span>n<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'.'</span><span class="token punctuation">:</span>                            p <span class="token operator">+=</span> <span class="token number">1</span>                        <span class="token comment"># 比小块</span>                        <span class="token keyword">if</span> board<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">3</span><span class="token operator">*</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">3</span><span class="token operator">*</span>n<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'.'</span> <span class="token keyword">and</span> board<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">3</span><span class="token operator">*</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">3</span><span class="token operator">*</span>n<span class="token punctuation">]</span> <span class="token keyword">not</span> <span class="token keyword">in</span> k<span class="token punctuation">:</span>                            k<span class="token punctuation">.</span>append<span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">3</span><span class="token operator">*</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">3</span><span class="token operator">*</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span>                        <span class="token comment"># 比横竖</span>                        <span class="token keyword">if</span> board<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">3</span><span class="token operator">*</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">3</span><span class="token operator">*</span>n<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'.'</span><span class="token punctuation">:</span>                             <span class="token keyword">if</span>  board<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">3</span><span class="token operator">*</span>m<span class="token punctuation">]</span><span class="token punctuation">.</span>count<span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">3</span><span class="token operator">*</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">3</span><span class="token operator">*</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token keyword">or</span> x<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">3</span><span class="token operator">*</span>n<span class="token punctuation">]</span><span class="token punctuation">.</span>count<span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">3</span><span class="token operator">*</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">3</span><span class="token operator">*</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">:</span>                                <span class="token keyword">return</span> <span class="token boolean">False</span>                <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">9</span> <span class="token operator">-</span> p<span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a>48. 旋转图像</h3><h4 id="问题：-10"><a href="#问题：-10" class="headerlink" title="问题："></a>问题：</h4><p><a href="https://leetcode-cn.com/problems/rotate-image/">https://leetcode-cn.com/problems/rotate-image/</a></p><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在 <strong>原地</strong> 旋转图像，这意味着你需要直接修改输入的二维矩阵。请<strong>不要</strong> 使用另一个矩阵来旋转图像。</p><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]输出：[[7,4,1],[8,5,2],[9,6,3]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">输入：matrix &#x3D; [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>提示：</p><pre class="line-numbers language-none"><code class="language-none">n &#x3D;&#x3D; matrix.length &#x3D;&#x3D; matrix[i].length1 &lt;&#x3D; n &lt;&#x3D; 20-1000 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 1000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解答：-10"><a href="#解答：-10" class="headerlink" title="解答："></a>解答：</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">rotate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Do not return anything, modify matrix in-place instead.        """</span>        length <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> i<span class="token operator">&lt;=</span>j<span class="token punctuation">:</span>                    matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>length<span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一道数学规律题。</p>]]></content>
      
      
      <categories>
          
          <category> Docs </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 初级算法 </tag>
            
            <tag> list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文略读2022-04-01</title>
      <link href="2022/04/01/22040101/"/>
      <url>2022/04/01/22040101/</url>
      
        <content type="html"><![CDATA[<h3 id="Heterogeneous-Graph-Attention-Network-for-Unsupervised-Multiple-Target-Domain-Adaptation"><a href="#Heterogeneous-Graph-Attention-Network-for-Unsupervised-Multiple-Target-Domain-Adaptation" class="headerlink" title="Heterogeneous Graph Attention Network for Unsupervised Multiple-Target Domain Adaptation"></a>Heterogeneous Graph Attention Network for Unsupervised Multiple-Target Domain Adaptation</h3><p>上线时间：2020-09-23<br>期刊：IEEE TPAMI<br>链接：<a href="https://ieeexplore.ieee.org/document/9204804">https://ieeexplore.ieee.org/document/9204804</a></p><p>工程意义：多目标域<br>工程创新：异构图注意力网络，学习域无关空间。<br>方法：通过异构图注意力网络学习所有域通用的统一子空间，其中图注意力网络的转导能力可以在多个域之间进行相关样本的语义传播。注意力机制被应用于优化多个领域样本的关系，以实现更好的语义转移。然后，利用图注意力网络预测的目标域的伪标签，通过对齐标记的源域和伪标记的目标域来学习域不变表示。</p><p>开源：否<br>评论：一直以来，使用图网络理论上会获得比传统深度网络更好的逻辑和方法，但在深度学习方法已经能做到disentanglement的情况下，这里用图网络来学domain invariant的内容，就显得在方法上写的不够先进。</p><img data-src="https://raw.githubusercontent.com/whiteloran/PicBed/master/img/202204011444959.png" width="80%"/><h3 id="Generalizable-Cross-modality-Medical-Image-Segmentation-via-Style-Augmentation-and-Dual-Normalization"><a href="#Generalizable-Cross-modality-Medical-Image-Segmentation-via-Style-Augmentation-and-Dual-Normalization" class="headerlink" title="Generalizable Cross-modality Medical Image Segmentation via Style Augmentation and Dual Normalization"></a>Generalizable Cross-modality Medical Image Segmentation via Style Augmentation and Dual Normalization</h3><p>上线时间：2021-12-21<br>期刊：CVPR 2022<br>链接：<a href="https://arxiv.org/abs/2112.11177">https://arxiv.org/abs/2112.11177</a></p><p>临床意义：更少的数据和标签需求<br>工程创新：从UDA到DG，应用风格增强+双路归一化。<br>方法：首先利用非线性变换来增强源相似和源不同的图像。共享主干网络，在归一化层进行单独归一化。之后，使用基于样式的选择方案，在测试阶段自动选择合适的数据路径。</p><p>开源：<a href="https://github.com/zzzqzhou/Dual-Normalization">https://github.com/zzzqzhou/Dual-Normalization</a><br>评论：一直以来很多工作都在试图用DG来代替UDA，但在公开数据上，DG常常结果一般。</p><img data-src="https://raw.githubusercontent.com/whiteloran/PicBed/master/img/202204011505495.png"/>]]></content>
      
      
      <categories>
          
          <category> Paper </category>
          
          <category> Daily Skim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Graph </tag>
            
            <tag> Disentanglement </tag>
            
            <tag> UDA </tag>
            
            <tag> DG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文略读2022-03-30</title>
      <link href="2022/03/30/22033001/"/>
      <url>2022/03/30/22033001/</url>
      
        <content type="html"><![CDATA[<h3 id="FReSCO-Flow-Reconstruction-and-Segmentation-for-low-latency-Cardiac-Output-monitoring-using-deep-artifact-suppression-and-segmentation"><a href="#FReSCO-Flow-Reconstruction-and-Segmentation-for-low-latency-Cardiac-Output-monitoring-using-deep-artifact-suppression-and-segmentation" class="headerlink" title="FReSCO: Flow Reconstruction and Segmentation for low latency Cardiac Output monitoring using deep artifact suppression and segmentation"></a>FReSCO: Flow Reconstruction and Segmentation for low latency Cardiac Output monitoring using deep artifact suppression and segmentation</h3><p>上线时间：2022-03-25<br>期刊：N/A<br>链接：<a href="https://arxiv.org/abs/2203.13729">https://arxiv.org/abs/2203.13729</a></p><p>临床意义：心输出量 (CO) 的实时监测需要实时相位对比 MR (PCMR) 的低延迟重建和分割。<br>工程创新：独立训练深度伪影抑制和分割 U-Net。<br>方法：独立训练深度伪影抑制和分割 U-Net。</p><p>开源：否<br>评论：临床意义还算可以，工程部分挺一般的。</p><img data-src="https://raw.githubusercontent.com/whiteloran/PicBed/master/img/202203301414363.png" width="80%" /><h3 id="Student-Become-Decathlon-Master-in-Retinal-Vessel-Segmentation-via-Dual-teacher-Multi-target-Domain-Adaptation"><a href="#Student-Become-Decathlon-Master-in-Retinal-Vessel-Segmentation-via-Dual-teacher-Multi-target-Domain-Adaptation" class="headerlink" title="Student Become Decathlon Master in Retinal Vessel Segmentation via Dual-teacher Multi-target Domain Adaptation"></a>Student Become Decathlon Master in Retinal Vessel Segmentation via Dual-teacher Multi-target Domain Adaptation</h3><p>上线时间：2022-03-07<br>期刊：N/A<br>链接：<a href="https://arxiv.org/abs/2203.03631">https://arxiv.org/abs/2203.03631</a></p><p>工程意义：多目标域适应。<br>工程创新：双重知识蒸馏<br>方法：风格增强和迁移（SAT）模块和双师知识蒸馏（DTKD）模块组成。SAT 通过贝塞尔和傅里叶变换将图像增强和聚类到源相似域和源不同域。DTKD 利用增强和转换的数据来训练两名教师，一个用于源相似域，另一个用于源不同域。之后，进行知识蒸馏，以迭代地将不同的领域知识从教师提炼到学生。</p><p>开源：暂未；<a href="https://github.com/lkpengcs/rvms">https://github.com/lkpengcs/rvms</a><br>评论：双重蒸馏已经挺常见的了，感觉创新性不是很足。变换法进行域转移的话，FedDG在好久前就有做过类似的。此外，视网膜图像在不同的中心条件下是相似的，或许这种UDA的效果不会很in the wild。</p><img data-src="https://raw.githubusercontent.com/whiteloran/PicBed/master/img/202203302111692.png" width="80%"/><h3 id="Multi-Source-Unsupervised-Domain-Adaptation-via-Pseudo-Target-Domain"><a href="#Multi-Source-Unsupervised-Domain-Adaptation-via-Pseudo-Target-Domain" class="headerlink" title="Multi-Source Unsupervised Domain Adaptation via Pseudo Target Domain"></a>Multi-Source Unsupervised Domain Adaptation via Pseudo Target Domain</h3><p>上线时间：2022-02-23<br>期刊：IEEE TIP<br>链接：<a href="https://ieeexplore.ieee.org/document/9720154">https://ieeexplore.ieee.org/document/9720154</a></p><p>工程意义：多源域适应<br>工程创新：构建伪目标域<br>方法：使用具有度量约束的对抗学习将每组源域和目标域映射到一个特定于组的子空间，并相应地构造一系列伪目标域。然后，将剩余源域与子空间中的伪目标域对齐，这允许通过对伪目标域的训练来利用额外的结构化源信息，并提高真实目标域的性能。</p><p>开源：否<br>评论：多源域适应是一个常见的问题，这个解法还行。此外，网络图画的不是很好看懂，因为没有主体。</p><img data-src="https://raw.githubusercontent.com/whiteloran/PicBed/master/img/202203302144316.png" width="80%"/>]]></content>
      
      
      <categories>
          
          <category> Paper </category>
          
          <category> Daily Skim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Domain Adaption </tag>
            
            <tag> Multi-domain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文略读2022-03-29</title>
      <link href="2022/03/29/22032901/"/>
      <url>2022/03/29/22032901/</url>
      
        <content type="html"><![CDATA[<h3 id="On-the-Fly-Test-time-Adaptation-for-Medical-Image-Segmentation"><a href="#On-the-Fly-Test-time-Adaptation-for-Medical-Image-Segmentation" class="headerlink" title="On-the-Fly Test-time Adaptation for Medical Image Segmentation"></a>On-the-Fly Test-time Adaptation for Medical Image Segmentation</h3><p>上线时间：2022-03-10<br>期刊：N/A<br>链接：<a href="https://arxiv.org/abs/2203.05574">https://arxiv.org/abs/2203.05574</a></p><p>临床意义：高速域适应：在现实世界的临床环境中，动态调整模型以适应新的测试图像并避免在推理过程中由于隐私问题和部署时缺乏计算资源而更新模型更有意义。<br>工程创新：zero-shot + episodic<br>方法：对Unet的每个卷积块都配备了一个自适应批量归一化层，以根据pre-train的域代码调整特征。</p><p>开源：<a href="https://github.com/jeya-maria-jose/On-The-Fly-Adaptation">https://github.com/jeya-maria-jose/On-The-Fly-Adaptation</a><br>评论：看到开头以为挺好，往后看了感觉一般。实验做得有点问题。</p><img data-src="https://raw.githubusercontent.com/whiteloran/PicBed/master/img/202203292110070.png" width="80%" /><blockquote><p>episodic (i.e., the model is adapted to a single image at a time and also does not perform any back-propagation during test-time)</p></blockquote><h3 id="Identifying-and-preventing-cardiovascular-disease-in-patients-with-cystic-fibrosis"><a href="#Identifying-and-preventing-cardiovascular-disease-in-patients-with-cystic-fibrosis" class="headerlink" title="Identifying and preventing cardiovascular disease in patients with cystic fibrosis"></a>Identifying and preventing cardiovascular disease in patients with cystic fibrosis</h3><p>上线时间：2022-03-10<br>期刊：Nature CVR<br>链接：<a href="https://www.nature.com/articles/s44161-022-00030-y">https://www.nature.com/articles/s44161-022-00030-y</a></p><p>临床声明：提高护理标准和新疗法意味着囊性纤维化患者的寿命更长，但这会增加患非传染性疾病的风险，尤其是心血管疾病 (CVD)。为了提高寿命和生活质量，重要的是要考虑囊性纤维化患者的 CVD 风险和预防措施。</p><p>评论：一篇comment。</p><img data-src="https://raw.githubusercontent.com/whiteloran/PicBed/master/img/202203292153743.png"/><h3 id="Active-Learning-for-Domain-Adaptation-An-Energy-Based-Approach"><a href="#Active-Learning-for-Domain-Adaptation-An-Energy-Based-Approach" class="headerlink" title="Active Learning for Domain Adaptation: An Energy-Based Approach"></a>Active Learning for Domain Adaptation: An Energy-Based Approach</h3><p>上线时间：2021-12-02<br>期刊：AAAI 2022<br>链接：<a href="https://arxiv.org/abs/2112.01406">https://arxiv.org/abs/2112.01406</a></p><p>工程意义：提出了一种新的主​​动学习策略来帮助目标域中的知识转移，称为主动域适应。<br>工程创新：当训练（源）和测试（目标）数据来自不同分布时，基于能量的模型表现出自由能偏差，基于能量的采样策略有助于选择最有价值的目标样本。<br>方法：查询目标数据组，在每一轮选择中纳入领域特征和实例的不确定性。同时，通过正则化项对齐目标数据的自由能与源域周围的自由能，隐性地缩小域之间的差距。</p><p>开源：<a href="https://github.com/BIT-DA/EADA">https://github.com/BIT-DA/EADA</a><br>评论：基于能量模型的UDA还是比较少见到的。或许我可以再看一下。</p><img data-src="https://raw.githubusercontent.com/whiteloran/PicBed/master/img/202203292214878.png" width="80%"/><h3 id="Dual-Modality-Volume-Measurement-Integrated-on-a-Ventricular-Assist-Device"><a href="#Dual-Modality-Volume-Measurement-Integrated-on-a-Ventricular-Assist-Device" class="headerlink" title="Dual-Modality Volume Measurement Integrated on a Ventricular Assist Device"></a>Dual-Modality Volume Measurement Integrated on a Ventricular Assist Device</h3><p>上线时间：2021-09-24<br>期刊：IEEE TBME<br>链接：<a href="https://ieeexplore.ieee.org/document/9547820">https://ieeexplore.ieee.org/document/9547820</a></p><p>临床挑战：使用一种传感器模式的体积测量需要在 VAD 植入后的特定时间重新校准。<br>工程创新：将超声和阻抗体积测量技术集成到心尖 VAD 中。</p><p>评论：硬件上的多模态测量。实验较为简单。</p><h3 id="Zero-Shot-Video-Object-Segmentation-With-Co-Attention-Siamese-Networks"><a href="#Zero-Shot-Video-Object-Segmentation-With-Co-Attention-Siamese-Networks" class="headerlink" title="Zero-Shot Video Object Segmentation With Co-Attention Siamese Networks"></a>Zero-Shot Video Object Segmentation With Co-Attention Siamese Networks</h3><p>上线时间：2020-11-24<br>期刊：IEEE TPAMI<br>链接：<a href="https://ieeexplore.ieee.org/document/9268466">https://ieeexplore.ieee.org/document/9268466</a></p><p>工程挑战：Zero-Shot<br>工程创新：差异化的共同注意力机制<br>方法：利用视频帧之间的内在相关性并结合全局共同注意力机制，学习短期时间段中外观和运动的判别前景表示。</p><p>评论：确切来说，这个方法没有进行对于时序的建模，有点类似Trans对LSTM的改变一样，这个网络抽取视频序列中的任意两帧输入网络，并建模帧和帧的关系。这样它能学到的关系其实是更丰富的。</p><img data-src="https://raw.githubusercontent.com/whiteloran/PicBed/master/img/202203292222357.png" width="80%"/>]]></content>
      
      
      <categories>
          
          <category> Paper </category>
          
          <category> Daily Skim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zero-shot </tag>
            
            <tag> Domain Adaption </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文略读2022-03-28</title>
      <link href="2022/03/28/22032801/"/>
      <url>2022/03/28/22032801/</url>
      
        <content type="html"><![CDATA[<h3 id="CrossMoDA-2021-challenge-Benchmark-of-Cross-Modality-Domain-Adaptation-techniques-for-Vestibular-Schwannoma-and-Cochlea-Segmentation"><a href="#CrossMoDA-2021-challenge-Benchmark-of-Cross-Modality-Domain-Adaptation-techniques-for-Vestibular-Schwannoma-and-Cochlea-Segmentation" class="headerlink" title="CrossMoDA 2021 challenge: Benchmark of Cross-Modality Domain Adaptation techniques for Vestibular Schwannoma and Cochlea Segmentation"></a>CrossMoDA 2021 challenge: Benchmark of Cross-Modality Domain Adaptation techniques for Vestibular Schwannoma and Cochlea Segmentation</h3><p>上线时间：2022-01-08<br>期刊：MIA</p><p>开源：<a href="https://paperswithcode.com/dataset/crossmoda">https://paperswithcode.com/dataset/crossmoda</a></p><p>评论：公开的脑部跨模态域适应数据集。</p><h3 id="MT-UDA-Towards-Unsupervised-Cross-modality-Medical-Image-Segmentation-with-Limited-Source-Labels"><a href="#MT-UDA-Towards-Unsupervised-Cross-modality-Medical-Image-Segmentation-with-Limited-Source-Labels" class="headerlink" title="MT-UDA: Towards Unsupervised Cross-modality Medical Image Segmentation with Limited Source Labels"></a>MT-UDA: Towards Unsupervised Cross-modality Medical Image Segmentation with Limited Source Labels</h3><p>上线时间：2021-09-21<br>期刊：MICCAI<br>链接：<a href="https://link.springer.com/chapter/10.1007/978-3-030-87193-2_28">https://link.springer.com/chapter/10.1007/978-3-030-87193-2_28</a></p><p>临床意义：通用意义，标签稀缺。<br>工程创新：A+B: Unsupervised DA + Knowledge Transfer<br>方法：双重师生模型+UDA</p><p>开源：<a href="https://github.com/jacobzhaoziyuan/MT-UDA">https://github.com/jacobzhaoziyuan/MT-UDA</a><br>评论：源域半监督+跨域UDA+双重师生模型。叠起来还是挺好的。双循环对位模块用于双向降低域漂移，生成近似源域和近似目标域。</p><img data-src="https://raw.githubusercontent.com/whiteloran/PicBed/master/img/202203281546360.png" width="80%"><img data-src="https://raw.githubusercontent.com/whiteloran/PicBed/master/img/202203281559651.png" width="80%"><h3 id="Semi-Supervised-Hybrid-Spine-Network-for-Segmentation-of-Spine-MR-Images"><a href="#Semi-Supervised-Hybrid-Spine-Network-for-Segmentation-of-Spine-MR-Images" class="headerlink" title="Semi-Supervised Hybrid Spine Network for Segmentation of Spine MR Images"></a>Semi-Supervised Hybrid Spine Network for Segmentation of Spine MR Images</h3><p>上线时间：2021-09-21<br>期刊：N/A<br>链接：<a href="https://arxiv.org/abs/2203.12151">https://arxiv.org/abs/2203.12151</a></p><p>临床意义：在3DMRI中，自动分割椎体 (VB) 和椎间盘 (IVD) 对于诊断和治疗脊柱疾病很重要。<br>工程创新：混合半监督+注意力机制<br>方法：2D+3D Deeplab + 三重注意力融合</p><p>开源：<a href="https://github.com/meiyan88/sshsnet">https://github.com/meiyan88/sshsnet</a></p><p>评论：用较长的篇幅解释清楚了怎么完成网络构建。</p><img data-src="https://raw.githubusercontent.com/whiteloran/PicBed/master/img/202203281602693.png" width="80%"><h3 id="JCS-An-Explainable-COVID-19-Diagnosis-System-by-Joint-Classification-and-Segmentation"><a href="#JCS-An-Explainable-COVID-19-Diagnosis-System-by-Joint-Classification-and-Segmentation" class="headerlink" title="JCS: An Explainable COVID-19 Diagnosis System by Joint Classification and Segmentation"></a>JCS: An Explainable COVID-19 Diagnosis System by Joint Classification and Segmentation</h3><p>上线时间：2021-02-18（投稿2020-03-16）<br>期刊：IEEE TIP<br>链接：<a href="https://ieeexplore.ieee.org/abstract/document/9357961/">https://ieeexplore.ieee.org/abstract/document/9357961/</a></p><p>临床意义：胸部CT扫描测试为RT-PCR测试提供补充信息，用于感染检查。<br>工程创新：联合分类和分割 (JCS) 系统来执行实时和可解释的 COVID-19 胸部 CT 诊断。<br>方法：双路网络。</p><p>开源：<a href="https://github.com/yuhuan-wu/JCS">https://github.com/yuhuan-wu/JCS</a><br>评论：写得快，数据集大加上有现实实践真的可以随便做的。</p><img data-src="https://raw.githubusercontent.com/whiteloran/PicBed/master/img/202203281613364.png" width="80%"><h3 id="Disentangled-Inference-for-GANs-With-Latently-Invertible-Autoencoder"><a href="#Disentangled-Inference-for-GANs-With-Latently-Invertible-Autoencoder" class="headerlink" title="Disentangled Inference for GANs With Latently Invertible Autoencoder"></a>Disentangled Inference for GANs With Latently Invertible Autoencoder</h3><p>上线时间：2022-03-22（投稿2020-03-16）<br>期刊：IJCV 2022<br>链接：<a href="https://link.springer.com/article/10.1007/s11263-022-01598-5">https://link.springer.com/article/10.1007/s11263-022-01598-5</a></p><p>工程挑战：生成对抗网络 (GAN) 无法在潜在空间中编码真实样本。we cannot infer the latent variable $z$ corresponding to a given sample $x$ such that the image can be faithfully reconstructed from $z$ by the GAN generator.<br>方法：潜在可逆自动编码器 (LIA) 。在 LIA 中，可逆网络及其逆映射对称地嵌入自编码器的潜在空间中。LIA 的解码器首先被训练为具有可逆网络的标准 GAN，然后通过将可逆网络从 LIA 中分离出来，从解纠缠的自动编码器中学习编码器。</p><p>开源：<a href="https://github.com/genforce/lia">https://github.com/genforce/lia</a><br>评论：对潜在空间的解纠缠的解析使用了VAE来完成，可以视作用VAE来外联GAN。能够对潜在空间解纠缠可以让GAN的生成的定向能力提升。</p><img data-src="https://raw.githubusercontent.com/whiteloran/PicBed/master/img/202203281624952.png" width="80%"><h3 id="CDTrans-Cross-domain-Transformer-for-Unsupervised-Domain-Adaptation"><a href="#CDTrans-Cross-domain-Transformer-for-Unsupervised-Domain-Adaptation" class="headerlink" title="CDTrans: Cross-domain Transformer for Unsupervised Domain Adaptation"></a>CDTrans: Cross-domain Transformer for Unsupervised Domain Adaptation</h3><p>上线时间：2021-09-13<br>期刊：ICCV 2021<br>链接：<a href="https://arxiv.org/abs/2109.06165">https://arxiv.org/abs/2109.06165</a></p><p>工程挑战：基于类别级别的 UDA 的一个基本问题是为目标域中的样本生成伪标签，这些伪标签通常对于准确的域对齐来说过于嘈杂，不可避免地会影响 UDA 的性能。<br>工程创新：Transformer 中的交叉注意力对嘈杂的输入对具有鲁棒性，可以更好地进行特征对齐。<br>方法：设计了一种双向中心感知标签算法来为目标样本生成伪标签。除了伪标签之外，还提出了一个权重共享的三分支转换器框架，以分别将自注意力和交叉注意力应用于源/目标特征学习和源-目标域对齐。</p><p>开源：<a href="https://github.com/cdtrans/cdtrans">https://github.com/cdtrans/cdtrans</a><br>评论：构造Transformer来完成UDA，降低伪标签的噪声影响。实验做得一般。</p><img data-src="https://raw.githubusercontent.com/whiteloran/PicBed/master/img/202203281703324.png" width="80%">]]></content>
      
      
      <categories>
          
          <category> Paper </category>
          
          <category> Daily Skim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Multi-modal </tag>
            
            <tag> Uncertainty estimation </tag>
            
            <tag> Zero-shot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文略读2022-03-23</title>
      <link href="2022/03/23/22032301/"/>
      <url>2022/03/23/22032301/</url>
      
        <content type="html"><![CDATA[<h3 id="Domain-Adaptation-Meets-Zero-Shot-Learning-An-Annotation-Efficient-Approach-to-Multi-Modality-Medical-Image-Segmentation"><a href="#Domain-Adaptation-Meets-Zero-Shot-Learning-An-Annotation-Efficient-Approach-to-Multi-Modality-Medical-Image-Segmentation" class="headerlink" title="Domain Adaptation Meets Zero-Shot Learning: An Annotation-Efficient Approach to Multi-Modality Medical Image Segmentation"></a>Domain Adaptation Meets Zero-Shot Learning: An Annotation-Efficient Approach to Multi-Modality Medical Image Segmentation</h3><p>上线时间：2021-11-29<br>期刊：IEEE TMI<br>链接：<a href="https://ieeexplore.ieee.org/abstract/document/9627926">https://ieeexplore.ieee.org/abstract/document/9627926</a></p><p>临床意义：通用意义，标签稀缺（UDA）。数据安全（ZSL）。<br>工程创新：A+B: Unsupervised DA + Zero-Shot L<br>方法：先验模型+适应模型</p><p>开源：否<br>评论：用ZSL来只利用从Source Domain学习到的模型，而不需要涉及到Source Domain所使用到的图像。这样避免了UDA在训练时需要Source Data的问题。虽然是A+B式的，但确实有效。</p><p><img data-src="https://raw.githubusercontent.com/whiteloran/PicBed/master/img/202203231559897.png"></p><h3 id="Beyond-Mutual-Information-Generative-Adversarial-Network-for-Domain-Adaptation-using-Information-Bottleneck-Constraint"><a href="#Beyond-Mutual-Information-Generative-Adversarial-Network-for-Domain-Adaptation-using-Information-Bottleneck-Constraint" class="headerlink" title="Beyond Mutual Information: Generative Adversarial Network for Domain Adaptation using Information Bottleneck Constraint"></a>Beyond Mutual Information: Generative Adversarial Network for Domain Adaptation using Information Bottleneck Constraint</h3><p>上线时间：2021-10-04<br>期刊：IEEE TMI<br>链接：<a href="https://ieeexplore.ieee.org/abstract/document/9558836">https://ieeexplore.ieee.org/abstract/document/9558836</a></p><p>临床意义：临床迁移部署。通用的。<br>工程创新：A+B: DA + CAD（computer aided diagnosis）<br>方法：Information Bottleneck Constraint<br>开源：否</p><p>评论：对比实验做得一般，毕竟没有做UDA。是一个img2img的工作。</p><p><img data-src="https://raw.githubusercontent.com/whiteloran/PicBed/master/img/202203231714268.png"></p><h3 id="Inconsistency-aware-Uncertainty-Estimation-for-Semi-supervised-Medical-Image-Segmentation"><a href="#Inconsistency-aware-Uncertainty-Estimation-for-Semi-supervised-Medical-Image-Segmentation" class="headerlink" title="Inconsistency-aware Uncertainty Estimation for Semi-supervised Medical Image Segmentation"></a>Inconsistency-aware Uncertainty Estimation for Semi-supervised Medical Image Segmentation</h3><p>上线时间：2021-10-04<br>期刊：IEEE TMI<br>链接：<a href="https://ieeexplore.ieee.org/abstract/document/9558816">https://ieeexplore.ieee.org/abstract/document/9558816</a></p><p>临床意义：通用的标签稀缺，加上比较新的辅助诊断可用的uncertainty。<br>工程创新：A+B：Uncertainty Estimation + 半监督<br>方法：双重分割策略。复合网络。<br>开源：否</p><p>评论：uncertainty的使用和实现比较有趣。这个本身是有临床潜力的，可以让医生更注重那些可能有问题的病例。在分割时使用了保守分割策略（更侧重前景）和激进分割策略（更侧重背景的正确）。为达成这一目的，在代价设置上，让不同比例的前景、背景像素具备相同的代价。保守分割和激进分割两者相同为certain，两者不同为uncertian。</p><p><img data-src="https://raw.githubusercontent.com/whiteloran/PicBed/master/img/202203231746920.png"></p><h3 id="Deep-Symmetric-Adaptation-Network-for-Cross-Modality-Medical-Image-Segmentation"><a href="#Deep-Symmetric-Adaptation-Network-for-Cross-Modality-Medical-Image-Segmentation" class="headerlink" title="Deep Symmetric Adaptation Network for Cross-Modality Medical Image Segmentation"></a>Deep Symmetric Adaptation Network for Cross-Modality Medical Image Segmentation</h3><p>上线时间：2021-08-16<br>期刊：IEEE TMI<br>链接：<a href="https://ieeexplore.ieee.org/abstract/document/9514499">https://ieeexplore.ieee.org/abstract/document/9514499</a></p><p>临床意义：通用的标签稀缺+部署困难。<br>工程创新：相互适应（？）<br>方法：复合网络。</p><p>开源：暂未开源： <a href="https://github.com/ting2696/Deep-Symmetric-Adaptation-Network">https://github.com/ting2696/Deep-Symmetric-Adaptation-Network</a><br>评论：Symmetric Adaptation，让源域和目标域相互适应。图1挺有特点。</p><p><img data-src="https://raw.githubusercontent.com/whiteloran/PicBed/master/img/202203281534187.png"></p>]]></content>
      
      
      <categories>
          
          <category> Paper </category>
          
          <category> Daily Skim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Multi-modal </tag>
            
            <tag> Uncertainty estimation </tag>
            
            <tag> Zero-shot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>费斯汀格法则</title>
      <link href="2022/03/22/22032201/"/>
      <url>2022/03/22/22032201/</url>
      
        <content type="html"><![CDATA[<p>费斯汀格法则，心理学术语，由美国社会心理学家费斯汀格（Festinger）提出。</p><p>此术语用于非定量地阐述，生活中的10%是由发生在个体身上的事情组成，而另外的90%则是由个体对所发生的事情如何反应所决定。</p>]]></content>
      
      
      <categories>
          
          <category> Writing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Social Science </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文略读2022-03-22</title>
      <link href="2022/03/22/22032203/"/>
      <url>2022/03/22/22032203/</url>
      
        <content type="html"><![CDATA[<h3 id="A-Dual-Meta-Learning-Framework-based-on-Idle-Data-for-Enhancing-Segmentation-of-Pancreatic-Cancer"><a href="#A-Dual-Meta-Learning-Framework-based-on-Idle-Data-for-Enhancing-Segmentation-of-Pancreatic-Cancer" class="headerlink" title="A Dual Meta-Learning Framework based on Idle Data for Enhancing Segmentation of Pancreatic Cancer"></a>A Dual Meta-Learning Framework based on Idle Data for Enhancing Segmentation of Pancreatic Cancer</h3><p>上线时间：2022-03-19<br>期刊：MIA<br>链接：<a href="https://doi.org/10.1016/j.media.2021.102342">https://doi.org/10.1016/j.media.2021.102342</a></p><p>临床意义：小尺寸和不显眼的边界限制了胰腺癌的自动分割性能。由于图像采集和注释的困难，深度学习必须要在训练样本较少的情况下进行。为了缓解由小规模数据集引起的问题，作者从不同的研究中收集了闲置的胰腺癌多参数 MRI，以构建一个相对较大的数据集来增强 CT 胰腺癌分割。<br>工程创新：双重元学习框架的深度学习分割模型。<br>开源：否<br>评论：前置是一个多模态img2img的trans工作用来做数据增强，主要的分割模型是用了共享参数的（中间模态-CT模态）的元学习方法。对比实验做的很多都是baseline，在relate work时也没广泛的描述。结果不显著。</p><p><img data-src="https://raw.githubusercontent.com/whiteloran/PicBed/master/img/202203222119342.png"></p><h3 id="Machine-learning-and-phone-data-can-improve-targeting-of-humanitarian-aid"><a href="#Machine-learning-and-phone-data-can-improve-targeting-of-humanitarian-aid" class="headerlink" title="Machine learning and phone data can improve targeting of humanitarian aid"></a>Machine learning and phone data can improve targeting of humanitarian aid</h3><p>上线时间：2022-03-16<br>期刊：Nature<br>链接：<a href="https://www.nature.com/articles/s41586-022-04484-9">https://www.nature.com/articles/s41586-022-04484-9</a></p><p>意义：来自移动电话网络的数据可以提高人道主义援助的针对性。<br>方法：使用传统的调查数据来训练机器学习算法，以识别手机数据中的贫困模式；然后，经过训练的算法可以优先向最贫困的移动用户提供援助。<br>结果：突出了新数据源补充传统人道主义援助目标方法的潜力。<br>开源：<a href="https://github.com/emilylaiken/togo-targeting-replication/">https://github.com/emilylaiken/togo-targeting-replication/</a></p><p>评论：机器学习的应用实例，实验规模大感觉确实是nature的先决条件啊。</p><h3 id="Instance-Importance-Aware-Graph-Convolutional-Network-for-3D-Medical-Diagnosis"><a href="#Instance-Importance-Aware-Graph-Convolutional-Network-for-3D-Medical-Diagnosis" class="headerlink" title="Instance Importance-Aware Graph Convolutional Network for 3D Medical Diagnosis"></a>Instance Importance-Aware Graph Convolutional Network for 3D Medical Diagnosis</h3><p>上线时间：2022-03-18<br>期刊：MIA<br>链接：<a href="https://doi.org/10.1016/j.media.2022.102421">https://doi.org/10.1016/j.media.2022.102421</a></p><p>临床意义：使用了患者标签，来做临床诊断。<br>方法：提出了一个实例重要性感知图卷积网络。用了multi-instance learning (MIL)。包括两方面，实例重要性和实例间感知。完成自动诊断任务。<br>开源：<a href="https://github.com/CityU-AIM-Group/I2GCN">https://github.com/CityU-AIM-Group/I2GCN</a></p><p>方法对比：通过将每个 2D 切片转换为一个实例嵌入，许多工作将 3D 扫描的实例嵌入聚合为 bag embedding，然后进行 bag prediction 以实现对 3D 医疗数据的诊断。这些实例聚合方法无法感知和利用不同实例对诊断的重要性。通过随机删除节点的广泛使用的图增强与 MIL 框架冲突。通过丢弃关键实例（即病变切片），它可能会将 3D 感染扫描更改为负样本，并导致增强样本与其标签之间的不一致。因此，为 MIL 框架量身定制的基于图的增强策略有望实现准确的 3D 医学诊断。</p><p>评论：用了图网络确实会容易中期刊。使用了混合3D的MRI和CT图像（来自CC-CCII和PROSTATEx）来证明方法的通用性。一个图分类任务。</p><p><img data-src="https://raw.githubusercontent.com/whiteloran/PicBed/master/img/202203222137599.png"></p><h3 id="Multimodality-Imaging-to-Assess-Leaflet-Height-in-Mitral-Bioprosthetic-Valves-Implications-for-Mitral-Valve-in-Valve-Procedure"><a href="#Multimodality-Imaging-to-Assess-Leaflet-Height-in-Mitral-Bioprosthetic-Valves-Implications-for-Mitral-Valve-in-Valve-Procedure" class="headerlink" title="Multimodality Imaging to Assess Leaflet Height in Mitral Bioprosthetic Valves: Implications for Mitral Valve-in-Valve Procedure"></a>Multimodality Imaging to Assess Leaflet Height in Mitral Bioprosthetic Valves: Implications for Mitral Valve-in-Valve Procedure</h3><p>上线时间：2022-03-16<br>期刊：JACC:Imaging<br>链接：<a href="https://www.jacc.org/doi/abs/10.1016/j.jcmg.2022.01.010">https://www.jacc.org/doi/abs/10.1016/j.jcmg.2022.01.010</a></p><p>评论：一个Imaging Vignette。讨论了多模态在二尖瓣修复手术的应用。包括了提取临床指标。可以作为多模态在困难病例上的广泛应用的实例。</p>]]></content>
      
      
      <categories>
          
          <category> Paper </category>
          
          <category> Daily Skim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Multi-modal </tag>
            
            <tag> Graph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过 Brust-Schiffrin 方法制备金纳米粒子</title>
      <link href="2022/03/18/22031801/"/>
      <url>2022/03/18/22031801/</url>
      
        <content type="html"><![CDATA[<p>金纳米粒子是研究较早的一种纳米材料，在生物学研究中一般将其称为胶体金。它的粒子尺寸一般在1~100nm之间，随粒径的变化呈现不同的颜色。另外，由于金纳米粒子具有很高的电子密度，在电子显微镜下具有很好的衬度，因此十分适合作为电镜测试的标记物。</p><p>1971年，Faulk和Taylor首先将胶体金作为标记物引入到免疫学研究中，通常称之为免疫金标记。之后，大量研究表明胶体金能够稳定而迅速地吸附蛋白质，而且蛋白质的生物活性不发生明显改变。它可以作为探针进行细胞表面和细胞内多糖、蛋白质、多肽、抗原、激素、核酸等生物大分子的精确定位，也可以用于常规的免疫诊断，进行免疫组织化学定位，因而在临床诊断及药物检测等方面得到了广泛的应用。</p><p>由此，金纳米颗粒的制备开始发展起来，到目前为止已经有了包括柠檬酸钠还原法等还原方法：如硼氢化钠还原法、抗坏血酸还原法等等；或是可以避免二次成核的种子成长法；又或是利用紫外线等的光化学方法。</p><p>从1994年出现的Brust-Schiffrin法，也即两相合成法，是一直在使用的热稳定合成方法。</p><p><img data-src="https://raw.githubusercontent.com/whiteloran/PicBed/master/img/20220318153343.png" alt="Brust-Schiffrin"></p><p>由于热稳定合成方法简单易行，在不到十年的时间内，此方法在所有领域都有重要的影响。金纳米粒子在有机溶剂中能分散和再溶解，并且没有不可逆的团聚或分解。作为有机分子化合物，它们能很容易的被控制和被功能化。</p><p>Faraday的两相合成体系给予合成技术一定的启发在NaBH4还原过程中，橙色相在几秒内向深棕色转变。其反应机理如图：</p><p><img data-src="https://raw.githubusercontent.com/whiteloran/PicBed/master/img/20220318154146.png" alt="Faraday"></p><p>该合成方法的操作步骤为:<br>1：分别将一定量的氯金酸溶于去离子水中，将四正辛基溴化铵(TOAB)溶于甲苯中；<br>2：将二者混合搅拌(发生的现象:水溶液相变澄清，而甲苯相变为橙色.此现象发生的原因:甲苯相中TOAB萃取水相中的AuCl4-)；<br>3：转移至分液漏斗中静止分层，取橙色甲苯相，将其置于冰水浴中；<br>4：加一定量的巯醇(如正十二烷基巯基醇)，搅拌至溶液接近无色，加NaBH,保存于冰水浴中24 h,将制备出热力学稳定的、粒径为1.5 ~5.2 nm的AuNPs.</p><p>该方法利用强的金硫键(Au-S)作用，合成出巯基配体修饰的AuNPs.改变合成反应条件，如适当增加巯醇/金盐的比例、调控反应温度和还原速率,便可制得尺寸更小和单分散性更好的AuNPs.<br>此方法制备出的AuNP’s 将有如下优点:<br>(1)稳定，可反复溶解于简单的有机溶剂中而不会聚集;<br>(2)奇特的光电特性;<br>(3)较高的比表面积和良好的生物相容性.</p><p><img data-src="https://raw.githubusercontent.com/whiteloran/PicBed/master/img/20220318154349.png" alt="AuNP"></p><p>其它含硫配体也已经用于稳定金纳米粒子（如黄酸盐和二硫化物）等。二硫化物不如硫醇稳定，但是在催化方面有明显的效果。同样，硫醚不能很好的约束金纳米粒子，但是利用聚硫醚就能很好的解决这个问题。另外，利用碘氧化以硫醇为包覆剂的金纳米粒子，能使其分解为金的碘化物和二碗化物。利用这一现像可以制备以金纳米粒子为模版的环糊精的空心球。</p>]]></content>
      
      
      <categories>
          
          <category> Material </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 纳米材料 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生物质磁性荧光纳米颗粒</title>
      <link href="2022/03/18/22031802/"/>
      <url>2022/03/18/22031802/</url>
      
        <content type="html"><![CDATA[<p>生物质磁性荧光纳米颗粒【Fe3O4@CS/CDs NPs(FCCs)】的平均粒径为10nm左右、等电点为pH=7.1，是以Fe3O4为核，CS为壳的核壳式结构。其制备方式有微波法、超重力沉淀反应法或是磁分离法。因为其的超顺磁性、低毒性、生物安全性好、表面活性高、吸附能力强、光学性能优异稳定等特点，可被应用于磁驱动靶向给药、实时监测药物位置浓度、药物缓控释、作为给药载体以及处理大规模废水等方面。</p>]]></content>
      
      
      <categories>
          
          <category> Material </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 纳米材料 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>海恩法则</title>
      <link href="2022/03/18/22031803/"/>
      <url>2022/03/18/22031803/</url>
      
        <content type="html"><![CDATA[<p>海恩法则，最初是航空界关于飞行安全的法则。它指出: 每一起严重事故的背后，必然有29次轻微事故和300起未遂先兆以及1000起事故隐患。</p><p>扩展来看，海恩法则强调两点：<br>一是事故的发生是量的积累的结果，量变引起质变；<br>二是在实际操作层面，现有的技术理论和制度理论都无法取代人自身的素质和对生产环境的修正能力，同时，此种修正能力也有其上限。</p>]]></content>
      
      
      <categories>
          
          <category> Writing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Social Science </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python pip 镜像源</title>
      <link href="2021/09/07/21101101/"/>
      <url>2021/09/07/21101101/</url>
      
        <content type="html"><![CDATA[<p>pip国内的一些镜像</p><p>阿里云 <a href="http://mirrors.aliyun.com/pypi/simple/">http://mirrors.aliyun.com/pypi/simple/</a><br>豆瓣 <a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a><br>清华大学 <a href="https://pypi.tuna.tsinghua.edu.cn/simple/">https://pypi.tuna.tsinghua.edu.cn/simple/</a><br>中国科学技术大学 <a href="http://pypi.mirrors.ustc.edu.cn/simple/">http://pypi.mirrors.ustc.edu.cn/simple/</a></p><p>pip install  -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 常用指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10系统下更改iCloud云盘位置</title>
      <link href="2021/09/02/21090201/"/>
      <url>2021/09/02/21090201/</url>
      
        <content type="html"><![CDATA[<p>因为iCloud不能在设置之中主动修改位置，故需要使用符号链接的方式，将文件夹进行映射。<br>具体操作如下：</p><ol><li><p>在目标位置创建文件夹，形如<code>D:\iCloudDrive</code></p></li><li><p>在<code>cmd</code>下创建符号链接:<br> <code>MKLINK /D C:\Users\UserID\iCloudDrive D:\iCloudDrive</code><br> 其中，<br> <code>C:\Users\UserID\iCloudDrive</code>内的<code>UserID</code>为账户名，整体作为iCloud的存储位置。</p></li><li><p>正常使用iCloud</p></li></ol><p>关于符号链接：</p><p>NTFS 符号链接又称“符号链接”，是 NTFS 文件系统中指向文件系统中的另一个对象的一类对象，被指向的对象叫做“目标”。<br><code>mklink</code> 是 Windows 下用于创建符号链接的工具，存在于 Windows Vista 及以后版本的 Windows 操作系统中。</p><p>使用方式：<br><code>MKLINK [[/D] | [/H] | [/J]] 链接名称 目标</code></p><p>说明：</p><ul><li>/D 创建目录符号链接而不是文件符号链接（默认为文件符号链接）</li><li>/H 创建硬链接而不是符号链接</li><li>/J 创建目录连接点</li><li>链接名称 指定新的符号链接名称</li><li>目标 指定新链接引用的路径（绝对路径或者相对路径均可）</li></ul><p>参见：<br><a href="https://baike.baidu.com/item/mklink/566760">https://baike.baidu.com/item/mklink/566760</a></p>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> win2mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS Code Remote-SSH 配置跳板机</title>
      <link href="2021/07/17/21071701/"/>
      <url>2021/07/17/21071701/</url>
      
        <content type="html"><![CDATA[<p>通过配置SSH的config文件来完成这个操作。<br>具体上，使用如下指令：</p><pre class="line-numbers language-none"><code class="language-none">Host Target  HostName target  User   Port   ProxyCommand ssh -W %h:%p Jump Host Jump  HostName Jump  User   Port   IdentityFile <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显然地，这一方法可以有效扩展到多重跳板。</p><pre class="line-numbers language-none"><code class="language-none">Host Target  HostName target  User   Port   ProxyCommand ssh -W %h:%p Jump2 Host Jump2  HostName jump2  User   Port   ProxyCommand ssh -W %h:%p Jump1Host Jump1  HostName jump1  User   Port <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSH </tag>
            
            <tag> VS Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 强制覆盖</title>
      <link href="2021/07/17/21071702/"/>
      <url>2021/07/17/21071702/</url>
      
        <content type="html"><![CDATA[<p>远程覆盖本地</p><pre class="line-numbers language-none"><code class="language-none">git fetch --allgit reset --hard origin&#x2F;master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>本地覆盖远程</p><pre class="line-numbers language-none"><code class="language-none">git push --force origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 常用指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS Code terminal change</title>
      <link href="2021/07/17/21071704/"/>
      <url>2021/07/17/21071704/</url>
      
        <content type="html"><![CDATA[<p>打开Setting，然后查询terminal。<br>在设置中选择terminal。</p>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VS Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AttributeError：&#39;DataFrame&#39; object has no attribute &#39;ix&#39;</title>
      <link href="2021/05/31/21053101/"/>
      <url>2021/05/31/21053101/</url>
      
        <content type="html"><![CDATA[<p><strong>问题描述：</strong> </p><pre class="line-numbers language-none"><code class="language-none">AttributeError: &#39;DataFrame&#39; object has no attribute &#39;ix&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>解决思路：</strong> </p><p>应该是Numpy库更改了名称</p><p><strong>解决方法：</strong></p><p><code>.ix</code>更改为<code>.iloc</code></p>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bugs Solution </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab：预分配内存和批量读取文件</title>
      <link href="2021/05/31/21053102/"/>
      <url>2021/05/31/21053102/</url>
      
        <content type="html"><![CDATA[<p>通过初始化相应大小的全零数组来预分配内存：</p><p>可以使用<code>repmat</code>函数进行分配。</p><p>通常来说，使用<code>zeros</code>函数即可。</p>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Excel：单元格自动填充和快速填充</title>
      <link href="2021/05/31/21053103/"/>
      <url>2021/05/31/21053103/</url>
      
        <content type="html"><![CDATA[<p>在使用Excel或是相似的表格工具时，一个常用的操作是拖动单元格右下角角点拖动对行列单元格进行填充。<br>一个非常显然的问题是，当这种操作不只用于填充少数行时，就会失去其便捷性，反而变得缓慢。<br>有表格软件自带的三类方法，可以完成单元格的快速填充。</p><ol><li>向下填充(Ctrl+D)</li><li>序列工具</li><li>快速填充(Ctrl+E)</li></ol>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Excel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Word,Latex&amp;Markdown</title>
      <link href="2021/04/10/21041001/"/>
      <url>2021/04/10/21041001/</url>
      
        <content type="html"><![CDATA[<p>Latex非常稳定，基本不会有无法预见的错误，一次编辑，一次成型。核心思想在于<strong>格式与内容分离</strong>，所以可以使用一些现成的模板，像PPT一样在这个模板里对文字进行编辑——或许这种做法可以一定程度地减轻复杂度。</p><p>WORD是最为常规与常用的选择，可以将WORD和WPS连用，虽然修改格式牵一发而动全身，且容易崩溃失去内容，但是<strong>所见即所得</strong>的特性让这种输入体系简单易用，在小心操作模板的情况下，也有较为舒适的输入体验。</p><p>MD是最适合用于常常部分修改内容的书写的体系，比如读书笔记或是计划书。<strong>混合格式与内容</strong>的MD可以算是上面两者的中和。但毫无疑问，这玩意暂时还没法用来写更多的论文，只有少数地方允许使用这种格式。</p>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 常识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm 换源镜像</title>
      <link href="2021/04/10/21041002/"/>
      <url>2021/04/10/21041002/</url>
      
        <content type="html"><![CDATA[<p>Node在执行npm命令时，从国外服务器下载第三方依赖包。在国内使用淘宝镜像会比较方便。</p><p>指定源:</p><pre class="line-numbers language-none"><code class="language-none">npm install --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>永久指定源：</p><pre class="line-numbers language-none"><code class="language-none">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.orgnpm config get registry<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>替换为cnpm:</p><pre class="line-numbers language-none"><code class="language-none">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org cnpm -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>常见镜像源：</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;r.cnpmjs.org&#x2F;http:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 常用指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 3 模块pywin32 加载问题</title>
      <link href="2021/04/05/21040302/"/>
      <url>2021/04/05/21040302/</url>
      
        <content type="html"><![CDATA[<p><strong>问题描述：</strong> </p><p><code>No matching distribution found for win32com</code></p><p><strong>解决思路：</strong> </p><p>考虑是模组命名问题。</p><p><strong>解决方法：</strong></p><p><del><code>pip install win32com</code></del></p><p><del><code>pip3 install pypiwin32</code></del></p><p><code>pip3 install pywin32</code></p><p>其中，<code>pypiwin32</code>是<code>pywin32</code>的过时版本，应该避免使用它，而使用目前仍在更新的<code>pywin32</code>。</p><p><img data-src="https://i.loli.net/2021/04/05/NBJOzZQ76XRerLK.png" alt="image.png"></p><p><strong>参考链接：</strong></p><p><a href="https://pypi.org/project/pywin32/">https://pypi.org/project/pywin32/</a></p><p><a href="https://github.com/mhammond/pywin32">https://github.com/mhammond/pywin32</a></p>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bugs Solution </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用‘空间稳定化’稳定纳米粒子的机制</title>
      <link href="2021/04/05/21040501/"/>
      <url>2021/04/05/21040501/</url>
      
        <content type="html"><![CDATA[<p>空间稳定是一种能够解释某些添加剂抑制悬浮液凝固能力的机理。这些添加剂包括某些亲水聚合物和具有亲水链的表面活性剂。这些添加剂被认为覆盖了整个体系，使长环和长尾延伸到溶液中。即使在高盐浓度或表面zeta电位降低到接近零的条件下，空间稳定的体系也倾向于保持良好的分散性。空间稳定剂的有效性归因于当人们试图将聚合物链限制在较小体积时的热力学惩罚。另一种解释是，这种链子更加亲水，它们与水保持接触，而不愿与任何其他表面相互作用（除了它们一端附着在表面上）。空间稳定化的物理基础有两个，一是体积限制效应产生于2个靠近粒子表面间的区域的减小，二是渗透效应产生于2个粒子高浓度吸附聚合物分子层间的区域。</p><p><img data-src="https://i.loli.net/2021/04/05/7wopaK9rmuMxFZ8.png" alt="image.png"></p><span id="more"></span><p>利用这种添加配体的性质，我们得以让体系中的纳米粒子更加稳定。这种机制是这样的：<br>空间稳定化基于分子间的空间排斥作用或吸附在邻近粒子上的离子的作用。这些分子的大小和化学性质决定了其稳定程度。由于纳米颗粒周围的几何约束，大而笨重的分子提供了一种特别有效的稳定性，而细长或圆锥形的几何结构有利于将接近的纳米颗粒分开。<br>当稳定剂的长度明显长于纳米颗粒的特征尺寸时，可以形成一个球体来包裹纳米颗粒。因此，高分子量聚合物常被用作纳米粒子的稳定剂。<br>另一个重要的要求是，稳定剂必须在纳米粒子表面有足够强的吸附力，以提供较长的停留时间，并防止其自发解吸。当稳定剂提供多个吸附中心时，螯合作用可增加稳定剂保持吸附的可能性。<br>通常，化学吸附是吸附质与金属表面强结合的驱动力。价轨道比价电子多的金属有一个“不导电”的表面。因此，分子容易“捐赠”电子密度（即与自由电子孤对相关联的化学基团，例如二价硫、三价磷和三价氮部分或具有π电子的分子，例如芳香系统）通常在金属表面吸附非常强烈。大分子具有强吸附性，是稳定纳米颗粒的主要候选物质。</p><p>空间稳定的概念对纳米粒子的成功合成起着非常重要的作用。可能单纯的理论说明会不够直观，我们来看几个例子。<br>比如氟化配体在超临界CO 2中纳米晶体的立体稳定上的作用。在空间稳定系统中的关键是具有良好溶剂化的配体尾部，这些尾部延伸到溶剂中并提供必要的排斥力，以克服纳米晶体之间的范德华力吸引。在超临界CO 2中纳米晶体的立体稳定中，部分氟化纳米晶体在极性溶剂（例如丙酮和乙醇）中的分散性可以通过CH 2 -CF 2基团的大偶极矩来合理化，这会与极性溶剂产生大量的偶极-偶极相互作用，从而导致链化从粒子表面延伸。<br>又比如铁磁流体，这是悬浮在连续相中的小的单畴磁性颗粒的胶态分散体。铁磁流体通常具有磁性和流体特性，并已在生物和医学的各个领域找到了广泛的应用，例如酶和蛋白质固定化，放射性药物，磁共振成像，诊断，免疫测定，纯化，分离和受控的药物释放。完全通过静电排斥或表面活性剂双层稳定的磁性纳米颗粒分散体的使用受到其对诸如pH值和离子强度之类条件的敏感性的限制，并且对于改变颗粒的表面性质几乎没有影响。这在生物学应用中尤其重要，在这些应用中，这些颗粒将被施用到活生物体中，并且需要在中性pH和高离子强度下都非常稳定。对于这些环境，磁性纳米颗粒的稳定化可以通过用有机聚合物材料/表面活性剂涂覆颗粒表面来实现，由于弹性和渗透作用的结合，表面活性剂可在颗粒之间提供空间排斥。</p><p>如上，是对利用‘空间稳定化’稳定纳米粒子的机制的简单说明。</p><p>引用：</p><ol><li><p>M.G. Ivanov, D.M. Ivanov,<br>Chapter 14 - Nanodiamond Nanoparticles as Additives to Lubricants,<br>Editor(s): Olga A. Shenderova, Dieter M. Gruen,<br>Ultananocrystalline Diamond (Second Edition),<br>William Andrew Publishing,<br>2012,<br>Pages 457-492,<br>ISBN 9781437734652,<br><a href="https://doi.org/10.1016/B978-1-4377-3465-2.00014-1">https://doi.org/10.1016/B978-1-4377-3465-2.00014-1</a>.<br>(<a href="http://www.sciencedirect.com/science/article/pii/B9781437734652000141">http://www.sciencedirect.com/science/article/pii/B9781437734652000141</a>)</p></li><li><p>G D Parfitt (deceased), H A Barnes,<br>Chapter 6 - The dispersion of fine particles in liquid media,<br>Editor(s): N Harnby, M F Edwards, A W Nienow,<br>Mixing in the Process Industries,<br>Butterworth-Heinemann,<br>1992,<br>Pages 99-117,<br>ISBN 9780750637602,<br><a href="https://doi.org/10.1016/B978-075063760-2/50027-5">https://doi.org/10.1016/B978-075063760-2/50027-5</a>.<br>(<a href="http://www.sciencedirect.com/science/article/pii/B9780750637602500275">http://www.sciencedirect.com/science/article/pii/B9780750637602500275</a>)</p></li><li><p>Sherif Elbasuney,<br>Sustainable steric stabilization of colloidal titania nanoparticles,<br>Applied Surface Science,<br>Volume 409,<br>2017,<br>Pages 438-447,<br>ISSN 0169-4332,<br><a href="https://doi.org/10.1016/j.apsusc.2017.03.013">https://doi.org/10.1016/j.apsusc.2017.03.013</a>.<br>(<a href="http://www.sciencedirect.com/science/article/pii/S0169433217306645">http://www.sciencedirect.com/science/article/pii/S0169433217306645</a>)</p></li><li><p>Optimized Steric Stabilization of Aqueous Ferrofluids and Magnetic Nanoparticles<br>Nirmesh Jain, Yanjun Wang, Stephen K. Jones, Brian S. Hawkett, and Gregory G. Warr<br>Langmuir 2010 26 (6), 4465-4472<br>DOI: 10.1021/la903513v</p></li><li><p>Alexander Kraynov and Thomas E. Müller (September 22nd 2011). Concepts for the      Stabilization of Metal Nanoparticles in Ionic Liquids, Applications of Ionic Liquids in Science and     Technology, Scott Handy, IntechOpen, DOI: 10.5772/22111.<br>Available from:<br><a href="https://www.intechopen.com/books/applications-of-ionic-liquids-in-science-and">https://www.intechopen.com/books/applications-of-ionic-liquids-in-science-and</a> technology/concepts-for-the-stabilization-of-metal-nanoparticles-in-ionic-liquids</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Material </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 纳米材料 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH RSA仅能在创建后首次使用正常运行 问题</title>
      <link href="2021/04/05/21040502/"/>
      <url>2021/04/05/21040502/</url>
      
        <content type="html"><![CDATA[<p><strong>问题描述：</strong> </p><p>ssh连接生成私钥后，仅首次连接才能使用，往后不能使用。</p><p><strong>解决思路：</strong> </p><p>电脑可能在长时程上有多个钥匙对，需要用config来指明使用对象。</p><p><strong>解决方法：</strong></p><p>配置<code>.ssh/config</code>。</p><p><img data-src="https://i.loli.net/2021/04/05/BA8gkQvwpXdsRuG.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bugs Solution </tag>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH：Enter passphrase for key</title>
      <link href="2021/04/05/21040503/"/>
      <url>2021/04/05/21040503/</url>
      
        <content type="html"><![CDATA[<p><strong>问题描述：</strong> </p><pre class="line-numbers language-none"><code class="language-none">SSH：Enter passphrase for keyCould not open a connection to your authentication agent.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>解决思路：</strong> </p><p>——</p><p><strong>解决方法：</strong></p><p><code>ssh-agent bash</code></p>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bugs Solution </tag>
            
            <tag> Old post </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git Bash中文输出乱码问题</title>
      <link href="2021/04/04/21040401/"/>
      <url>2021/04/04/21040401/</url>
      
        <content type="html"><![CDATA[<p><strong>问题描述：</strong>Git Bash下运行代码输出中文文本时出现乱码和未成功显示，英文如常。<br><strong>解决思路：</strong>考虑是编码问题。<br><strong>解决方法：</strong>右键打开Options，在text选项卡中，如下图所示修改编码即可。</p><p><img data-src="https://i.loli.net/2021/04/04/CHi2eNOSmrndXwZ.png" alt="clipboard.png"></p>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bugs Solution </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 3 模块Crypto 加载问题</title>
      <link href="2021/04/04/21040402/"/>
      <url>2021/04/04/21040402/</url>
      
        <content type="html"><![CDATA[<p><strong>问题描述：</strong><code>pip3 install crypto </code>后，仍然无法读取模块。</p><p><strong>解决思路：</strong>考虑是模组命名问题。</p><p><strong>解决方法：</strong><del>打开Python环境模组安装位置，修改crypto文件夹的名称。</del></p><p>选择安全性更高的<code>pycryptodome</code>。<code>pip3 install pycryptodome</code>。</p><p><img data-src="https://i.loli.net/2021/04/04/NXUYfiC4wZWrcbg.png" alt="image-20210403223749181.png"></p><p>参考链接：<a href="https://pypi.org/project/pycryptodome/">https://pypi.org/project/pycryptodome/</a></p>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bugs Solution </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 3 模块iso639  加载问题</title>
      <link href="2021/04/03/21040301/"/>
      <url>2021/04/03/21040301/</url>
      
        <content type="html"><![CDATA[<p><strong>问题描述：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> iso639 <span class="token keyword">import</span> languages ImportError<span class="token punctuation">:</span> cannot <span class="token keyword">import</span> name <span class="token string">'languages'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>解决思路：</strong>考虑是模组命名问题。</p><p><strong>解决方法：</strong>有错误的同名模组。在安装时应为，<code>pip install iso-639</code> 。</p><p>参考链接：<br><a href="https://pypi.org/project/iso-639/">https://pypi.org/project/iso-639/</a><br><a href="https://pypi.org/project/iso639/">https://pypi.org/project/iso639/</a></p>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bugs Solution </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
